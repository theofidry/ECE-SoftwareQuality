


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: compiler</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.tools.javac.resources</a> ]
</div>

<h1>Coverage Summary for Class: compiler (com.sun.tools.javac.resources)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">compiler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;//
<i>2</i>&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
<i>3</i>&nbsp;// (powered by Fernflower decompiler)
<i>4</i>&nbsp;//
<b class="nc"><i>5</i>&nbsp;</b>
<i>6</i>&nbsp;package com.sun.tools.javac.resources;
<b class="nc"><i>7</i>&nbsp;</b>
<i>8</i>&nbsp;import java.util.ListResourceBundle;
<i>9</i>&nbsp;
<i>10</i>&nbsp;public final class compiler extends ListResourceBundle {
<i>11</i>&nbsp;    public compiler() {
<i>12</i>&nbsp;    }
<i>13</i>&nbsp;
<i>14</i>&nbsp;    protected final Object[][] getContents() {
<i>15</i>&nbsp;        return new Object[][]{{&quot;compiler.err.abstract.cant.be.accessed.directly&quot;, &quot;abstract {0} {1} in {2} cannot be accessed directly&quot;}, {&quot;compiler.err.abstract.cant.be.instantiated&quot;, &quot;{0} is abstract; cannot be instantiated&quot;}, {&quot;compiler.err.abstract.meth.cant.have.body&quot;, &quot;abstract methods cannot have a body&quot;}, {&quot;compiler.err.already.annotated&quot;, &quot;{0} {1} has already been annotated&quot;}, {&quot;compiler.err.already.defined&quot;, &quot;{0} {1} is already defined in {2} {3}&quot;}, {&quot;compiler.err.already.defined.in.clinit&quot;, &quot;{0} {1} is already defined in {2} of {3} {4}&quot;}, {&quot;compiler.err.already.defined.single.import&quot;, &quot;{0} is already defined in a single-type import&quot;}, {&quot;compiler.err.already.defined.static.single.import&quot;, &quot;{0} is already defined in a static single-type import&quot;}, {&quot;compiler.err.already.defined.this.unit&quot;, &quot;{0} is already defined in this compilation unit&quot;}, {&quot;compiler.err.annotation.missing.default.value&quot;, &quot;annotation {0} is missing value for the attribute {1}&quot;}, {&quot;compiler.err.annotation.missing.default.value.1&quot;, &quot;annotation {0} is missing values for attributes {1}&quot;}, {&quot;compiler.err.annotation.not.valid.for.type&quot;, &quot;annotation not valid for a value of type {0}&quot;}, {&quot;compiler.err.annotation.type.not.applicable&quot;, &quot;annotation type not applicable to this kind of declaration&quot;}, {&quot;compiler.err.annotation.value.must.be.annotation&quot;, &quot;annotation value must be an annotation&quot;}, {&quot;compiler.err.annotation.value.must.be.class.literal&quot;, &quot;annotation value must be a class literal&quot;}, {&quot;compiler.err.annotation.value.must.be.name.value&quot;, &quot;annotation values must be of the form \&#39;\&#39;name=value\&#39;\&#39;&quot;}, {&quot;compiler.err.annotation.value.not.allowable.type&quot;, &quot;annotation value not of an allowable type&quot;}, {&quot;compiler.err.annotations.not.supported.in.source&quot;, &quot;annotations are not supported in -source {0}\n(use -source 5 or higher to enable annotations)&quot;}, {&quot;compiler.err.anon.class.impl.intf.no.args&quot;, &quot;anonymous class implements interface; cannot have arguments&quot;}, {&quot;compiler.err.anon.class.impl.intf.no.qual.for.new&quot;, &quot;anonymous class implements interface; cannot have qualifier for new&quot;}, {&quot;compiler.err.anon.class.impl.intf.no.typeargs&quot;, &quot;anonymous class implements interface; cannot have type arguments&quot;}, {&quot;compiler.err.array.and.varargs&quot;, &quot;cannot declare both {0} and {1} in {2}&quot;}, {&quot;compiler.err.array.dimension.missing&quot;, &quot;array dimension missing&quot;}, {&quot;compiler.err.array.req.but.found&quot;, &quot;array required, but {0} found&quot;}, {&quot;compiler.err.assert.as.identifier&quot;, &quot;as of release 1.4, \&#39;\&#39;assert\&#39;\&#39; is a keyword, and may not be used as an identifier\n(use -source 1.3 or lower to use \&#39;\&#39;assert\&#39;\&#39; as an identifier)&quot;}, {&quot;compiler.err.assignment.from.super-bound&quot;, &quot;assigning from wildcard {0}&quot;}, {&quot;compiler.err.assignment.to.extends-bound&quot;, &quot;assigning to wildcard {0}&quot;}, {&quot;compiler.err.attribute.value.must.be.constant&quot;, &quot;attribute value must be constant&quot;}, {&quot;compiler.err.break.outside.switch.loop&quot;, &quot;break outside switch or loop&quot;}, {&quot;compiler.err.call.must.be.first.stmt.in.ctor&quot;, &quot;call to {0} must be first statement in constructor&quot;}, {&quot;compiler.err.call.to.super.not.allowed.in.enum.ctor&quot;, &quot;call to super not allowed in enum constructor&quot;}, {&quot;compiler.err.cannot.create.array.with.diamond&quot;, &quot;cannot create array with \&#39;\&#39;&lt;&gt;\&#39;\&#39;&quot;}, {&quot;compiler.err.cannot.create.array.with.type.arguments&quot;, &quot;cannot create array with type arguments&quot;}, {&quot;compiler.err.cant.access&quot;, &quot;cannot access {0}\n{1}&quot;}, {&quot;compiler.err.cant.apply.diamond&quot;, &quot;cannot infer type arguments for {0}&quot;}, {&quot;compiler.err.cant.apply.diamond.1&quot;, &quot;cannot infer type arguments for {0};\nreason: {1}&quot;}, {&quot;compiler.err.cant.apply.symbol&quot;, &quot;{0} {1} in {4} {5} cannot be applied to given types\nrequired: {2}\nfound: {3}&quot;}, {&quot;compiler.err.cant.apply.symbol.1&quot;, &quot;{0} {1} in {4} {5} cannot be applied to given types;\nrequired: {2}\nfound: {3}\nreason: {6}&quot;}, {&quot;compiler.err.cant.apply.symbols&quot;, &quot;no suitable {0} found for {1}({2})&quot;}, {&quot;compiler.err.cant.assign.val.to.final.var&quot;, &quot;cannot assign a value to final variable {0}&quot;}, {&quot;compiler.err.cant.deref&quot;, &quot;{0} cannot be dereferenced&quot;}, {&quot;compiler.err.cant.extend.intf.annotation&quot;, &quot;\&#39;\&#39;extends\&#39;\&#39; not allowed for @interfaces&quot;}, {&quot;compiler.err.cant.inherit.diff.arg&quot;, &quot;{0} cannot be inherited with different arguments: &lt;{1}&gt; and &lt;{2}&gt;&quot;}, {&quot;compiler.err.cant.inherit.from.final&quot;, &quot;cannot inherit from final {0}&quot;}, {&quot;compiler.err.cant.read.file&quot;, &quot;cannot read: {0}&quot;}, {&quot;compiler.err.cant.ref.before.ctor.called&quot;, &quot;cannot reference {0} before supertype constructor has been called&quot;}, {&quot;compiler.err.cant.resolve&quot;, &quot;cannot find symbol\nsymbol: {0} {1}&quot;}, {&quot;compiler.err.cant.resolve.args&quot;, &quot;cannot find symbol\nsymbol: {0} {1}({3})&quot;}, {&quot;compiler.err.cant.resolve.args.params&quot;, &quot;cannot find symbol\nsymbol: {0} &lt;{2}&gt;{1}({3})&quot;}, {&quot;compiler.err.cant.resolve.location&quot;, &quot;cannot find symbol\nsymbol:   {0} {1}\nlocation: {4}&quot;}, {&quot;compiler.err.cant.resolve.location.args&quot;, &quot;cannot find symbol\nsymbol:   {0} {1}({3})\nlocation: {4}&quot;}, {&quot;compiler.err.cant.resolve.location.args.params&quot;, &quot;cannot find symbol\nsymbol:   {0} &lt;{2}&gt;{1}({3})\nlocation: {4}&quot;}, {&quot;compiler.err.cant.ret.val.from.meth.decl.void&quot;, &quot;cannot return a value from method whose result type is void&quot;}, {&quot;compiler.err.cant.select.static.class.from.param.type&quot;, &quot;cannot select a static class from a parameterized type&quot;}, {&quot;compiler.err.catch.without.try&quot;, &quot;\&#39;\&#39;catch\&#39;\&#39; without \&#39;\&#39;try\&#39;\&#39;&quot;}, {&quot;compiler.err.clash.with.pkg.of.same.name&quot;, &quot;{0} {1} clashes with package of same name&quot;}, {&quot;compiler.err.class.cant.write&quot;, &quot;error while writing {0}: {1}&quot;}, {&quot;compiler.err.class.public.should.be.in.file&quot;, &quot;class {0} is public, should be declared in a file named {0}.java&quot;}, {&quot;compiler.err.concrete.inheritance.conflict&quot;, &quot;methods {0} from {1} and {2} from {3} are inherited with the same signature&quot;}, {&quot;compiler.err.const.expr.req&quot;, &quot;constant expression required&quot;}, {&quot;compiler.err.cont.outside.loop&quot;, &quot;continue outside of loop&quot;}, {&quot;compiler.err.cyclic.annotation.element&quot;, &quot;cyclic annotation element type&quot;}, {&quot;compiler.err.cyclic.inheritance&quot;, &quot;cyclic inheritance involving {0}&quot;}, {&quot;compiler.err.default.allowed.in.intf.annotation.member&quot;, &quot;default value only allowed in an @interface member&quot;}, {&quot;compiler.err.diamond.not.supported.in.source&quot;, &quot;diamond operator is not supported in -source {0}\n(use -source 7 or higher to enable diamond operator)&quot;}, {&quot;compiler.err.does.not.override.abstract&quot;, &quot;{0} is not abstract and does not override abstract method {1} in {2}&quot;}, {&quot;compiler.err.doesnt.exist&quot;, &quot;package {0} does not exist&quot;}, {&quot;compiler.err.dot.class.expected&quot;, &quot;\&#39;\&#39;.class\&#39;\&#39; expected&quot;}, {&quot;compiler.err.duplicate.annotation&quot;, &quot;duplicate annotation&quot;}, {&quot;compiler.err.duplicate.annotation.member.value&quot;, &quot;duplicate annotation member value {0} in {1}&quot;}, {&quot;compiler.err.duplicate.case.label&quot;, &quot;duplicate case label&quot;}, {&quot;compiler.err.duplicate.class&quot;, &quot;duplicate class: {0}&quot;}, {&quot;compiler.err.duplicate.default.label&quot;, &quot;duplicate default label&quot;}, {&quot;compiler.err.else.without.if&quot;, &quot;\&#39;\&#39;else\&#39;\&#39; without \&#39;\&#39;if\&#39;\&#39;&quot;}, {&quot;compiler.err.empty.char.lit&quot;, &quot;empty character literal&quot;}, {&quot;compiler.err.encl.class.required&quot;, &quot;an enclosing instance that contains {0} is required&quot;}, {&quot;compiler.err.enum.annotation.must.be.enum.constant&quot;, &quot;an enum annotation value must be an enum constant&quot;}, {&quot;compiler.err.enum.as.identifier&quot;, &quot;as of release 5, \&#39;\&#39;enum\&#39;\&#39; is a keyword, and may not be used as an identifier\n(use -source 1.4 or lower to use \&#39;\&#39;enum\&#39;\&#39; as an identifier)&quot;}, {&quot;compiler.err.enum.cant.be.instantiated&quot;, &quot;enum types may not be instantiated&quot;}, {&quot;compiler.err.enum.label.must.be.unqualified.enum&quot;, &quot;an enum switch case label must be the unqualified name of an enumeration constant&quot;}, {&quot;compiler.err.enum.no.finalize&quot;, &quot;enums cannot have finalize methods&quot;}, {&quot;compiler.err.enum.no.subclassing&quot;, &quot;classes cannot directly extend java.lang.Enum&quot;}, {&quot;compiler.err.enum.types.not.extensible&quot;, &quot;enum types are not extensible&quot;}, {&quot;compiler.err.enums.must.be.static&quot;, &quot;enum declarations allowed only in static contexts&quot;}, {&quot;compiler.err.enums.not.supported.in.source&quot;, &quot;enums are not supported in -source {0}\n(use -source 5 or higher to enable enums)&quot;}, {&quot;compiler.err.error&quot;, &quot;error: &quot;}, {&quot;compiler.err.error.reading.file&quot;, &quot;error reading {0}; {1}&quot;}, {&quot;compiler.err.except.already.caught&quot;, &quot;exception {0} has already been caught&quot;}, {&quot;compiler.err.except.never.thrown.in.try&quot;, &quot;exception {0} is never thrown in body of corresponding try statement&quot;}, {&quot;compiler.err.expected&quot;, &quot;{0} expected&quot;}, {&quot;compiler.err.expected2&quot;, &quot;{0} or {1} expected&quot;}, {&quot;compiler.err.expected3&quot;, &quot;{0}, {1}, or {2} expected&quot;}, {&quot;compiler.err.final.parameter.may.not.be.assigned&quot;, &quot;final parameter {0} may not be assigned&quot;}, {&quot;compiler.err.finally.without.try&quot;, &quot;\&#39;\&#39;finally\&#39;\&#39; without \&#39;\&#39;try\&#39;\&#39;&quot;}, {&quot;compiler.err.foreach.not.applicable.to.type&quot;, &quot;for-each not applicable to expression type\nrequired: {1}\nfound:    {0}&quot;}, {&quot;compiler.err.foreach.not.supported.in.source&quot;, &quot;for-each loops are not supported in -source {0}\n(use -source 5 or higher to enable for-each loops)&quot;}, {&quot;compiler.err.fp.number.too.large&quot;, &quot;floating point number too large&quot;}, {&quot;compiler.err.fp.number.too.small&quot;, &quot;floating point number too small&quot;}, {&quot;compiler.err.generic.array.creation&quot;, &quot;generic array creation&quot;}, {&quot;compiler.err.generic.throwable&quot;, &quot;a generic class may not extend java.lang.Throwable&quot;}, {&quot;compiler.err.generics.not.supported.in.source&quot;, &quot;generics are not supported in -source {0}\n(use -source 5 or higher to enable generics)&quot;}, {&quot;compiler.err.icls.cant.have.static.decl&quot;, &quot;Illegal static declaration in inner class {0}\nmodifier \&#39;\&#39;static\&#39;\&#39; is only allowed in constant variable declarations&quot;}, {&quot;compiler.err.illegal.char&quot;, &quot;illegal character: \\{0}&quot;}, {&quot;compiler.err.illegal.char.for.encoding&quot;, &quot;unmappable character for encoding {0}&quot;}, {&quot;compiler.err.illegal.combination.of.modifiers&quot;, &quot;illegal combination of modifiers: {0} and {1}&quot;}, {&quot;compiler.err.illegal.enum.static.ref&quot;, &quot;illegal reference to static field from initializer&quot;}, {&quot;compiler.err.illegal.esc.char&quot;, &quot;illegal escape character&quot;}, {&quot;compiler.err.illegal.forward.ref&quot;, &quot;illegal forward reference&quot;}, {&quot;compiler.err.illegal.generic.type.for.instof&quot;, &quot;illegal generic type for instanceof&quot;}, {&quot;compiler.err.illegal.initializer.for.type&quot;, &quot;illegal initializer for {0}&quot;}, {&quot;compiler.err.illegal.line.end.in.char.lit&quot;, &quot;illegal line end in character literal&quot;}, {&quot;compiler.err.illegal.nonascii.digit&quot;, &quot;illegal non-ASCII digit&quot;}, {&quot;compiler.err.illegal.qual.not.icls&quot;, &quot;illegal qualifier; {0} is not an inner class&quot;}, {&quot;compiler.err.illegal.self.ref&quot;, &quot;self-reference in initializer&quot;}, {&quot;compiler.err.illegal.start.of.expr&quot;, &quot;illegal start of expression&quot;}, {&quot;compiler.err.illegal.start.of.type&quot;, &quot;illegal start of type&quot;}, {&quot;compiler.err.illegal.underscore&quot;, &quot;illegal underscore&quot;}, {&quot;compiler.err.illegal.unicode.esc&quot;, &quot;illegal unicode escape&quot;}, {&quot;compiler.err.import.requires.canonical&quot;, &quot;import requires canonical name for {0}&quot;}, {&quot;compiler.err.improperly.formed.type.inner.raw.param&quot;, &quot;improperly formed type, type arguments given on a raw type&quot;}, {&quot;compiler.err.improperly.formed.type.param.missing&quot;, &quot;improperly formed type, some parameters are missing&quot;}, {&quot;compiler.err.incomparable.types&quot;, &quot;incomparable types: {0} and {1}&quot;}, {&quot;compiler.err.initializer.must.be.able.to.complete.normally&quot;, &quot;initializer must be able to complete normally&quot;}, {&quot;compiler.err.int.number.too.large&quot;, &quot;integer number too large: {0}&quot;}, {&quot;compiler.err.internal.error.cant.instantiate&quot;, &quot;internal error; cannot instantiate {0} at {1} to ({2})&quot;}, {&quot;compiler.err.intf.annotation.cant.have.type.params&quot;, &quot;@interface may not have type parameters&quot;}, {&quot;compiler.err.intf.annotation.member.clash&quot;, &quot;@interface member clashes with method \&#39;\&#39;{0}\&#39;\&#39; in {1}&quot;}, {&quot;compiler.err.intf.annotation.members.cant.have.params&quot;, &quot;@interface members may not have parameters&quot;}, {&quot;compiler.err.intf.annotation.members.cant.have.type.params&quot;, &quot;@interface members may not have type parameters&quot;}, {&quot;compiler.err.intf.expected.here&quot;, &quot;interface expected here&quot;}, {&quot;compiler.err.intf.meth.cant.have.body&quot;, &quot;interface methods cannot have body&quot;}, {&quot;compiler.err.intf.not.allowed.here&quot;, &quot;interface not allowed here&quot;}, {&quot;compiler.err.invalid.annotation.member.type&quot;, &quot;invalid type for annotation member&quot;}, {&quot;compiler.err.invalid.binary.number&quot;, &quot;binary numbers must contain at least one binary digit&quot;}, {&quot;compiler.err.invalid.hex.number&quot;, &quot;hexadecimal numbers must contain at least one hexadecimal digit&quot;}, {&quot;compiler.err.invalid.inferred.types&quot;, &quot;invalid inferred types for {0}; {1}&quot;}, {&quot;compiler.err.invalid.meth.decl.ret.type.req&quot;, &quot;invalid method declaration; return type required&quot;}, {&quot;compiler.err.io.exception&quot;, &quot;error reading source file: {0}&quot;}, {&quot;compiler.err.label.already.in.use&quot;, &quot;label {0} already in use&quot;}, {&quot;compiler.err.limit.code&quot;, &quot;code too large&quot;}, {&quot;compiler.err.limit.code.too.large.for.try.stmt&quot;, &quot;code too large for try statement&quot;}, {&quot;compiler.err.limit.dimensions&quot;, &quot;array type has too many dimensions&quot;}, {&quot;compiler.err.limit.locals&quot;, &quot;too many local variables&quot;}, {&quot;compiler.err.limit.parameters&quot;, &quot;too many parameters&quot;}, {&quot;compiler.err.limit.pool&quot;, &quot;too many constants&quot;}, {&quot;compiler.err.limit.pool.in.class&quot;, &quot;too many constants in class {0}&quot;}, {&quot;compiler.err.limit.stack&quot;, &quot;code requires too much stack&quot;}, {&quot;compiler.err.limit.string&quot;, &quot;constant string too long&quot;}, {&quot;compiler.err.limit.string.overflow&quot;, &quot;UTF8 representation for string \&quot;{0}...\&quot; is too long for the constant pool&quot;}, {&quot;compiler.err.local.enum&quot;, &quot;enum types must not be local&quot;}, {&quot;compiler.err.local.var.accessed.from.icls.needs.final&quot;, &quot;local variable {0} is accessed from within inner class; needs to be declared final&quot;}, {&quot;compiler.err.malformed.fp.lit&quot;, &quot;malformed floating point literal&quot;}, {&quot;compiler.err.method.does.not.override.superclass&quot;, &quot;method does not override or implement a method from a supertype&quot;}, {&quot;compiler.err.missing.meth.body.or.decl.abstract&quot;, &quot;missing method body, or declare abstract&quot;}, {&quot;compiler.err.missing.ret.stmt&quot;, &quot;missing return statement&quot;}, {&quot;compiler.err.missing.ret.val&quot;, &quot;missing return value&quot;}, {&quot;compiler.err.mod.not.allowed.here&quot;, &quot;modifier {0} not allowed here&quot;}, {&quot;compiler.err.multicatch.not.supported.in.source&quot;, &quot;multi-catch statement is not supported in -source {0}\n(use -source 7 or higher to enable multi-catch statement)&quot;}, {&quot;compiler.err.multicatch.parameter.may.not.be.assigned&quot;, &quot;multi-catch parameter {0} may not be assigned&quot;}, {&quot;compiler.err.multicatch.types.must.be.disjoint&quot;, &quot;Alternatives in a multi-catch statement cannot be related by subclassing\nAlternative {0} is a subclass of alternative {1}&quot;}, {&quot;compiler.err.name.clash.same.erasure&quot;, &quot;name clash: {0} and {1} have the same erasure&quot;}, {&quot;compiler.err.name.clash.same.erasure.no.hide&quot;, &quot;name clash: {0} in {1} and {2} in {3} have the same erasure, yet neither hides the other&quot;}, {&quot;compiler.err.name.clash.same.erasure.no.override&quot;, &quot;name clash: {0} in {1} and {2} in {3} have the same erasure, yet neither overrides the other&quot;}, {&quot;compiler.err.name.clash.same.erasure.no.override.1&quot;, &quot;name clash: {0} in {1} overrides a method whose erasure is the same as another method, yet neither overrides the other\nfirst method:  {2} in {3}\nsecond method: {4} in {5}&quot;}, {&quot;compiler.err.name.reserved.for.internal.use&quot;, &quot;{0} is reserved for internal use&quot;}, {&quot;compiler.err.native.meth.cant.have.body&quot;, &quot;native methods cannot have a body&quot;}, {&quot;compiler.err.neither.conditional.subtype&quot;, &quot;incompatible types for ?: neither is a subtype of the other\nsecond operand: {0}\nthird operand : {1}&quot;}, {&quot;compiler.err.new.not.allowed.in.annotation&quot;, &quot;\&#39;\&#39;new\&#39;\&#39; not allowed in an annotation&quot;}, {&quot;compiler.err.no.annotation.member&quot;, &quot;no annotation member {0} in {1}&quot;}, {&quot;compiler.err.no.encl.instance.of.type.in.scope&quot;, &quot;no enclosing instance of type {0} is in scope&quot;}, {&quot;compiler.err.no.intf.expected.here&quot;, &quot;no interface expected here&quot;}, {&quot;compiler.err.no.match.entry&quot;, &quot;{0} has no match in entry in {1}; required {2}&quot;}, {&quot;compiler.err.no.superclass&quot;, &quot;{0} has no superclass&quot;}, {&quot;compiler.err.non-static.cant.be.ref&quot;, &quot;non-static {0} {1} cannot be referenced from a static context&quot;}, {&quot;compiler.err.not.annotation.type&quot;, &quot;{0} is not an annotation type&quot;}, {&quot;compiler.err.not.def.access.class.intf.cant.access&quot;, &quot;{0} in {1} is defined in an inaccessible class or interface&quot;}, {&quot;compiler.err.not.def.public.cant.access&quot;, &quot;{0} is not public in {1}; cannot be accessed from outside package&quot;}, {&quot;compiler.err.not.encl.class&quot;, &quot;not an enclosing class: {0}&quot;}, {&quot;compiler.err.not.loop.label&quot;, &quot;not a loop label: {0}&quot;}, {&quot;compiler.err.not.stmt&quot;, &quot;not a statement&quot;}, {&quot;compiler.err.not.within.bounds&quot;, &quot;type argument {0} is not within bounds of type-variable {1}&quot;}, {&quot;compiler.err.operator.cant.be.applied&quot;, &quot;bad operand type {1} for unary operator \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;compiler.err.operator.cant.be.applied.1&quot;, &quot;bad operand types for binary operator \&#39;\&#39;{0}\&#39;\&#39;\nfirst type:  {1}\nsecond type: {2}&quot;}, {&quot;compiler.err.orphaned&quot;, &quot;orphaned {0}&quot;}, {&quot;compiler.err.override.incompatible.ret&quot;, &quot;{0}\nreturn type {1} is not compatible with {2}&quot;}, {&quot;compiler.err.override.meth&quot;, &quot;{0}\noverridden method is {1}&quot;}, {&quot;compiler.err.override.meth.doesnt.throw&quot;, &quot;{0}\noverridden method does not throw {1}&quot;}, {&quot;compiler.err.override.static&quot;, &quot;{0}\noverriding method is static&quot;}, {&quot;compiler.err.override.weaker.access&quot;, &quot;{0}\nattempting to assign weaker access privileges; was {1}&quot;}, {&quot;compiler.err.pkg.annotations.sb.in.package-info.java&quot;, &quot;package annotations should be in file package-info.java&quot;}, {&quot;compiler.err.pkg.clashes.with.class.of.same.name&quot;, &quot;package {0} clashes with class of same name&quot;}, {&quot;compiler.err.premature.eof&quot;, &quot;reached end of file while parsing&quot;}, {&quot;compiler.err.prob.found.req&quot;, &quot;{0}\nrequired: {2}\nfound:    {1}&quot;}, {&quot;compiler.err.prob.found.req.1&quot;, &quot;{0} {3}\nrequired: {2}\nfound:    {1}&quot;}, {&quot;compiler.err.proc.bad.config.file&quot;, &quot;Bad service configuration file, or exception thrown while constructing Processor object: {0}&quot;}, {&quot;compiler.err.proc.cant.access&quot;, &quot;cannot access {0}\n{1}\nConsult the following stack trace for details.\n{2}&quot;}, {&quot;compiler.err.proc.cant.access.1&quot;, &quot;cannot access {0}\n{1}&quot;}, {&quot;compiler.err.proc.cant.create.loader&quot;, &quot;Could not create class loader for annotation processors: {0}&quot;}, {&quot;compiler.err.proc.cant.find.class&quot;, &quot;Could not find class file for \&#39;\&#39;{0}\&#39;\&#39;.&quot;}, {&quot;compiler.err.proc.messager&quot;, &quot;{0}&quot;}, {&quot;compiler.err.proc.no.explicit.annotation.processing.requested&quot;, &quot;Class names, \&#39;\&#39;{0}\&#39;\&#39;, are only accepted if annotation processing is explicitly requested&quot;}, {&quot;compiler.err.proc.no.service&quot;, &quot;A service loader class could not be found.\nEither java.util.ServiceLoader or sun.misc.Service must be available.&quot;}, {&quot;compiler.err.proc.processor.bad.option.name&quot;, &quot;Bad option name \&#39;\&#39;{0}\&#39;\&#39; provided by processor \&#39;\&#39;{1}\&#39;\&#39;&quot;}, {&quot;compiler.err.proc.processor.cant.instantiate&quot;, &quot;Could not instantiate an instance of processor \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;compiler.err.proc.processor.constructor.error&quot;, &quot;Exception thrown while constructing Processor object: {0}&quot;}, {&quot;compiler.err.proc.processor.not.found&quot;, &quot;Annotation processor \&#39;\&#39;{0}\&#39;\&#39; not found&quot;}, {&quot;compiler.err.proc.processor.wrong.type&quot;, &quot;Annotation processor \&#39;\&#39;{0}\&#39;\&#39; does not implement javax.annotation.processing.Processor&quot;}, {&quot;compiler.err.proc.service.problem&quot;, &quot;Error creating a service loader to load Processors.&quot;}, {&quot;compiler.err.qualified.new.of.static.class&quot;, &quot;qualified new of static class&quot;}, {&quot;compiler.err.recursive.ctor.invocation&quot;, &quot;recursive constructor invocation&quot;}, {&quot;compiler.err.ref.ambiguous&quot;, &quot;reference to {0} is ambiguous, both {1} {2} in {3} and {4} {5} in {6} match&quot;}, {&quot;compiler.err.repeated.annotation.target&quot;, &quot;repeated annotation target&quot;}, {&quot;compiler.err.repeated.interface&quot;, &quot;repeated interface&quot;}, {&quot;compiler.err.repeated.modifier&quot;, &quot;repeated modifier&quot;}, {&quot;compiler.err.report.access&quot;, &quot;{0} has {1} access in {2}&quot;}, {&quot;compiler.err.ret.outside.meth&quot;, &quot;return outside method&quot;}, {&quot;compiler.err.signature.doesnt.match.intf&quot;, &quot;signature does not match {0}; incompatible interfaces&quot;}, {&quot;compiler.err.signature.doesnt.match.supertype&quot;, &quot;signature does not match {0}; incompatible supertype&quot;}, {&quot;compiler.err.source.cant.overwrite.input.file&quot;, &quot;error writing source; cannot overwrite input file {0}&quot;}, {&quot;compiler.err.stack.sim.error&quot;, &quot;Internal error: stack sim error on {0}&quot;}, {&quot;compiler.err.static.imp.only.classes.and.interfaces&quot;, &quot;static import only from classes and interfaces&quot;}, {&quot;compiler.err.static.import.not.supported.in.source&quot;, &quot;static import declarations are not supported in -source {0}\n(use -source 5 or higher to enable static import declarations)&quot;}, {&quot;compiler.err.string.const.req&quot;, &quot;constant string expression required&quot;}, {&quot;compiler.err.string.switch.not.supported.in.source&quot;, &quot;strings in switch are not supported in -source {0}\n(use -source 7 or higher to enable strings in switch)&quot;}, {&quot;compiler.err.synthetic.name.conflict&quot;, &quot;the symbol {0} conflicts with a compiler-synthesized symbol in {1}&quot;}, {&quot;compiler.err.throws.not.allowed.in.intf.annotation&quot;, &quot;throws clause not allowed in @interface members&quot;}, {&quot;compiler.err.try.resource.may.not.be.assigned&quot;, &quot;auto-closeable resource {0} may not be assigned&quot;}, {&quot;compiler.err.try.with.resources.not.supported.in.source&quot;, &quot;try-with-resources is not supported in -source {0}\n(use -source 7 or higher to enable try-with-resources)&quot;}, {&quot;compiler.err.try.without.catch.finally.or.resource.decls&quot;, &quot;\&#39;\&#39;try\&#39;\&#39; without \&#39;\&#39;catch\&#39;\&#39;, \&#39;\&#39;finally\&#39;\&#39; or resource declarations&quot;}, {&quot;compiler.err.try.without.catch.or.finally&quot;, &quot;\&#39;\&#39;try\&#39;\&#39; without \&#39;\&#39;catch\&#39;\&#39; or \&#39;\&#39;finally\&#39;\&#39;&quot;}, {&quot;compiler.err.type.doesnt.take.params&quot;, &quot;type {0} does not take parameters&quot;}, {&quot;compiler.err.type.found.req&quot;, &quot;unexpected type\nrequired: {1}\nfound:    {0}&quot;}, {&quot;compiler.err.type.var.cant.be.deref&quot;, &quot;cannot select from a type variable&quot;}, {&quot;compiler.err.type.var.may.not.be.followed.by.other.bounds&quot;, &quot;a type variable may not be followed by other bounds&quot;}, {&quot;compiler.err.type.var.more.than.once&quot;, &quot;type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated&quot;}, {&quot;compiler.err.type.var.more.than.once.in.result&quot;, &quot;type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated&quot;}, {&quot;compiler.err.types.incompatible.diff.ret&quot;, &quot;types {0} and {1} are incompatible; both define {2}, but with unrelated return types&quot;}, {&quot;compiler.err.unclosed.char.lit&quot;, &quot;unclosed character literal&quot;}, {&quot;compiler.err.unclosed.comment&quot;, &quot;unclosed comment&quot;}, {&quot;compiler.err.unclosed.str.lit&quot;, &quot;unclosed string literal&quot;}, {&quot;compiler.err.undef.label&quot;, &quot;undefined label: {0}&quot;}, {&quot;compiler.err.undetermined.type&quot;, &quot;cannot infer type arguments for {0}&quot;}, {&quot;compiler.err.undetermined.type.1&quot;, &quot;cannot infer type arguments for {0};\nreason: {1}&quot;}, {&quot;compiler.err.unexpected.type&quot;, &quot;unexpected type\nrequired: {0}\nfound:    {1}&quot;}, {&quot;compiler.err.unreachable.stmt&quot;, &quot;unreachable statement&quot;}, {&quot;compiler.err.unreported.exception.default.constructor&quot;, &quot;unreported exception {0} in default constructor&quot;}, {&quot;compiler.err.unreported.exception.implicit.close&quot;, &quot;unreported exception {0}; must be caught or declared to be thrown\nexception thrown from implicit call to close() on resource variable \&#39;\&#39;{1}\&#39;\&#39;&quot;}, {&quot;compiler.err.unreported.exception.need.to.catch.or.throw&quot;, &quot;unreported exception {0}; must be caught or declared to be thrown&quot;}, {&quot;compiler.err.unsupported.binary.lit&quot;, &quot;binary literals are not supported in -source {0}\n(use -source 7 or higher to enable binary literals)&quot;}, {&quot;compiler.err.unsupported.cross.fp.lit&quot;, &quot;hexadecimal floating-point literals are not supported on this VM&quot;}, {&quot;compiler.err.unsupported.encoding&quot;, &quot;unsupported encoding: {0}&quot;}, {&quot;compiler.err.unsupported.fp.lit&quot;, &quot;hexadecimal floating point literals are not supported in -source {0}\n(use -source 5 or higher to enable hexadecimal floating point literals)&quot;}, {&quot;compiler.err.unsupported.underscore.lit&quot;, &quot;underscores in literals are not supported in -source {0}\n(use -source 7 or higher to enable underscores in literals)&quot;}, {&quot;compiler.err.var.might.already.be.assigned&quot;, &quot;variable {0} might already have been assigned&quot;}, {&quot;compiler.err.var.might.be.assigned.in.loop&quot;, &quot;variable {0} might be assigned in loop&quot;}, {&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;variable {0} might not have been initialized&quot;}, {&quot;compiler.err.varargs.and.old.array.syntax&quot;, &quot;legacy array notation not allowed on variable-arity parameter&quot;}, {&quot;compiler.err.varargs.invalid.trustme.anno&quot;, &quot;Invalid {0} annotation. {1}&quot;}, {&quot;compiler.err.varargs.not.supported.in.source&quot;, &quot;variable-arity methods are not supported in -source {0}\n(use -source 5 or higher to enable variable-arity methods)&quot;}, {&quot;compiler.err.void.not.allowed.here&quot;, &quot;\&#39;\&#39;void\&#39;\&#39; type not allowed here&quot;}, {&quot;compiler.err.warnings.and.werror&quot;, &quot;warnings found and -Werror specified&quot;}, {&quot;compiler.err.wrong.number.type.args&quot;, &quot;wrong number of type arguments; required {0}&quot;}, {&quot;compiler.err.wrong.target.for.polymorphic.signature.definition&quot;, &quot;MethodHandle API building requires -target 7 runtimes or better; current is -target {0}&quot;}, {&quot;compiler.misc.anonymous.class&quot;, &quot;&lt;anonymous {0}&gt;&quot;}, {&quot;compiler.misc.arg.length.mismatch&quot;, &quot;actual and formal argument lists differ in length&quot;}, {&quot;compiler.misc.assignment.from.super-bound&quot;, &quot;assignment from super-bound type {0}&quot;}, {&quot;compiler.misc.assignment.to.extends-bound&quot;, &quot;assignment to extends-bound type {0}&quot;}, {&quot;compiler.misc.bad.class.file.header&quot;, &quot;bad class file: {0}\n{1}\nPlease remove or make sure it appears in the correct subdirectory of the classpath.&quot;}, {&quot;compiler.misc.bad.class.signature&quot;, &quot;bad class signature: {0}&quot;}, {&quot;compiler.misc.bad.const.pool.tag&quot;, &quot;bad constant pool tag: {0}&quot;}, {&quot;compiler.misc.bad.const.pool.tag.at&quot;, &quot;bad constant pool tag: {0} at {1}&quot;}, {&quot;compiler.misc.bad.enclosing.class&quot;, &quot;bad enclosing class for {0}: {1}&quot;}, {&quot;compiler.misc.bad.enclosing.method&quot;, &quot;bad enclosing method attribute for class {0}&quot;}, {&quot;compiler.misc.bad.runtime.invisible.param.annotations&quot;, &quot;bad RuntimeInvisibleParameterAnnotations attribute: {0}&quot;}, {&quot;compiler.misc.bad.signature&quot;, &quot;bad signature: {0}&quot;}, {&quot;compiler.misc.bad.source.file.header&quot;, &quot;bad source file: {0}\n{1}\nPlease remove or make sure it appears in the correct subdirectory of the sourcepath.&quot;}, {&quot;compiler.misc.base.membership&quot;, &quot;all your base class are belong to us&quot;}, {&quot;compiler.misc.cant.implement&quot;, &quot;{0} in {1} cannot implement {2} in {3}&quot;}, {&quot;compiler.misc.cant.override&quot;, &quot;{0} in {1} cannot override {2} in {3}&quot;}, {&quot;compiler.misc.captured.type&quot;, &quot;CAP#{0}&quot;}, {&quot;compiler.misc.ccf.found.later.version&quot;, &quot;class file has later version than expected: {0}&quot;}, {&quot;compiler.misc.ccf.unrecognized.attribute&quot;, &quot;unrecognized attribute: {0}&quot;}, {&quot;compiler.misc.clashes.with&quot;, &quot;{0} in {1} clashes with {2} in {3}&quot;}, {&quot;compiler.misc.class.file.not.found&quot;, &quot;class file for {0} not found&quot;}, {&quot;compiler.misc.class.file.wrong.class&quot;, &quot;class file contains wrong class: {0}&quot;}, {&quot;compiler.misc.count.error&quot;, &quot;{0} error&quot;}, {&quot;compiler.misc.count.error.plural&quot;, &quot;{0} errors&quot;}, {&quot;compiler.misc.count.warn&quot;, &quot;{0} warning&quot;}, {&quot;compiler.misc.count.warn.plural&quot;, &quot;{0} warnings&quot;}, {&quot;compiler.misc.diamond&quot;, &quot;{0}&lt;&gt;&quot;}, {&quot;compiler.misc.diamond.and.anon.class&quot;, &quot;cannot use \&#39;\&#39;&lt;&gt;\&#39;\&#39; with anonymous inner classes&quot;}, {&quot;compiler.misc.diamond.and.explicit.params&quot;, &quot;cannot use \&#39;\&#39;&lt;&gt;\&#39;\&#39; with explicit type parameters for constructor&quot;}, {&quot;compiler.misc.diamond.non.generic&quot;, &quot;cannot use \&#39;\&#39;&lt;&gt;\&#39;\&#39; with non-generic class {0}&quot;}, {&quot;compiler.misc.explicit.param.do.not.conform.to.bounds&quot;, &quot;explicit type argument {0} does not conform to declared bound(s) {1}&quot;}, {&quot;compiler.misc.fatal.err.cant.close.loader&quot;, &quot;Fatal Error: Cannot close class loader for annotation processors&quot;}, {&quot;compiler.misc.fatal.err.cant.locate.ctor&quot;, &quot;Fatal Error: Unable to find constructor for {0}&quot;}, {&quot;compiler.misc.fatal.err.cant.locate.field&quot;, &quot;Fatal Error: Unable to find field {0}&quot;}, {&quot;compiler.misc.fatal.err.cant.locate.meth&quot;, &quot;Fatal Error: Unable to find method {0}&quot;}, {&quot;compiler.misc.fatal.err.no.java.lang&quot;, &quot;Fatal Error: Unable to find package java.lang in classpath or bootclasspath&quot;}, {&quot;compiler.misc.file.does.not.contain.package&quot;, &quot;file does not contain package {0}&quot;}, {&quot;compiler.misc.file.doesnt.contain.class&quot;, &quot;file does not contain class {0}&quot;}, {&quot;compiler.misc.illegal.start.of.class.file&quot;, &quot;illegal start of class file&quot;}, {&quot;compiler.misc.inaccessible.varargs.type&quot;, &quot;formal varargs element type {0} is not accessible from {1} {2}&quot;}, {&quot;compiler.misc.inapplicable.method&quot;, &quot;{0} {1}.{2} is not applicable\n({3})&quot;}, {&quot;compiler.misc.incompatible.types&quot;, &quot;incompatible types&quot;}, {&quot;compiler.misc.incompatible.types.1&quot;, &quot;incompatible types; {0}&quot;}, {&quot;compiler.misc.incompatible.upper.bounds&quot;, &quot;inference variable {0} has incompatible upper bounds {1}&quot;}, {&quot;compiler.misc.inconvertible.types&quot;, &quot;inconvertible types&quot;}, {&quot;compiler.misc.infer.arg.length.mismatch&quot;, &quot;cannot instantiate from arguments because actual and formal argument lists differ in length&quot;}, {&quot;compiler.misc.infer.no.conforming.assignment.exists&quot;, &quot;no instance(s) of type variable(s) {0} exist so that argument type {1} conforms to formal parameter type {2}&quot;}, {&quot;compiler.misc.infer.no.conforming.instance.exists&quot;, &quot;no instance(s) of type variable(s) {0} exist so that {1} conforms to {2}&quot;}, {&quot;compiler.misc.inferred.do.not.conform.to.bounds&quot;, &quot;inferred type does not conform to declared bound(s)\ninferred: {0}\nbound(s): {1}&quot;}, {&quot;compiler.misc.intersection.type&quot;, &quot;INT#{0}&quot;}, {&quot;compiler.misc.kindname.annotation&quot;, &quot;@interface&quot;}, {&quot;compiler.misc.kindname.class&quot;, &quot;class&quot;}, {&quot;compiler.misc.kindname.constructor&quot;, &quot;constructor&quot;}, {&quot;compiler.misc.kindname.enum&quot;, &quot;enum&quot;}, {&quot;compiler.misc.kindname.instance.init&quot;, &quot;instance initializer&quot;}, {&quot;compiler.misc.kindname.interface&quot;, &quot;interface&quot;}, {&quot;compiler.misc.kindname.method&quot;, &quot;method&quot;}, {&quot;compiler.misc.kindname.package&quot;, &quot;package&quot;}, {&quot;compiler.misc.kindname.static&quot;, &quot;static&quot;}, {&quot;compiler.misc.kindname.static.init&quot;, &quot;static initializer&quot;}, {&quot;compiler.misc.kindname.type.variable&quot;, &quot;type variable&quot;}, {&quot;compiler.misc.kindname.type.variable.bound&quot;, &quot;bound of type variable&quot;}, {&quot;compiler.misc.kindname.value&quot;, &quot;value&quot;}, {&quot;compiler.misc.kindname.variable&quot;, &quot;variable&quot;}, {&quot;compiler.misc.location&quot;, &quot;{0} {1}&quot;}, {&quot;compiler.misc.location.1&quot;, &quot;{0} {1} of type {2}&quot;}, {&quot;compiler.misc.no.args&quot;, &quot;no arguments&quot;}, {&quot;compiler.misc.no.conforming.assignment.exists&quot;, &quot;actual argument {0} cannot be converted to {1} by method invocation conversion&quot;}, {&quot;compiler.misc.no.unique.maximal.instance.exists&quot;, &quot;no unique maximal instance exists for type variable {0} with upper bounds {1}&quot;}, {&quot;compiler.misc.no.unique.minimal.instance.exists&quot;, &quot;no unique minimal instance exists for type variable {0} with lower bounds {1}&quot;}, {&quot;compiler.misc.possible.loss.of.precision&quot;, &quot;possible loss of precision&quot;}, {&quot;compiler.misc.resume.abort&quot;, &quot;R)esume, A)bort&gt;&quot;}, {&quot;compiler.misc.source.unavailable&quot;, &quot;(source unavailable)&quot;}, {&quot;compiler.misc.token.bad-symbol&quot;, &quot;&lt;bad symbol&gt;&quot;}, {&quot;compiler.misc.token.character&quot;, &quot;&lt;character&gt;&quot;}, {&quot;compiler.misc.token.double&quot;, &quot;&lt;double&gt;&quot;}, {&quot;compiler.misc.token.end-of-input&quot;, &quot;&lt;end of input&gt;&quot;}, {&quot;compiler.misc.token.float&quot;, &quot;&lt;float&gt;&quot;}, {&quot;compiler.misc.token.identifier&quot;, &quot;&lt;identifier&gt;&quot;}, {&quot;compiler.misc.token.integer&quot;, &quot;&lt;integer&gt;&quot;}, {&quot;compiler.misc.token.long-integer&quot;, &quot;&lt;long integer&gt;&quot;}, {&quot;compiler.misc.token.string&quot;, &quot;&lt;string&gt;&quot;}, {&quot;compiler.misc.try.not.applicable.to.type&quot;, &quot;try-with-resources not applicable to variable type&quot;}, {&quot;compiler.misc.type.captureof&quot;, &quot;capture#{0} of {1}&quot;}, {&quot;compiler.misc.type.captureof.1&quot;, &quot;capture#{0}&quot;}, {&quot;compiler.misc.type.none&quot;, &quot;&lt;none&gt;&quot;}, {&quot;compiler.misc.type.null&quot;, &quot;&lt;null&gt;&quot;}, {&quot;compiler.misc.type.parameter&quot;, &quot;type parameter {0}&quot;}, {&quot;compiler.misc.type.req.array.or.iterable&quot;, &quot;array or java.lang.Iterable&quot;}, {&quot;compiler.misc.type.req.class&quot;, &quot;class&quot;}, {&quot;compiler.misc.type.req.class.array&quot;, &quot;class or array&quot;}, {&quot;compiler.misc.type.req.exact&quot;, &quot;class or interface without bounds&quot;}, {&quot;compiler.misc.type.req.ref&quot;, &quot;reference&quot;}, {&quot;compiler.misc.type.var&quot;, &quot;{0}#{1}&quot;}, {&quot;compiler.misc.type.variable.has.undetermined.type&quot;, &quot;type variable {0} has undetermined type&quot;}, {&quot;compiler.misc.unable.to.access.file&quot;, &quot;unable to access file: {0}&quot;}, {&quot;compiler.misc.unchecked.assign&quot;, &quot;unchecked conversion&quot;}, {&quot;compiler.misc.unchecked.cast.to.type&quot;, &quot;unchecked cast&quot;}, {&quot;compiler.misc.unchecked.clash.with&quot;, &quot;{0} in {1} overrides {2} in {3}&quot;}, {&quot;compiler.misc.unchecked.implement&quot;, &quot;{0} in {1} implements {2} in {3}&quot;}, {&quot;compiler.misc.unchecked.override&quot;, &quot;{0} in {1} overrides {2} in {3}&quot;}, {&quot;compiler.misc.undecl.type.var&quot;, &quot;undeclared type variable: {0}&quot;}, {&quot;compiler.misc.undetermined.type&quot;, &quot;undetermined type&quot;}, {&quot;compiler.misc.unicode.str.not.supported&quot;, &quot;unicode string in class file not supported&quot;}, {&quot;compiler.misc.unnamed.package&quot;, &quot;unnamed package&quot;}, {&quot;compiler.misc.varargs.argument.mismatch&quot;, &quot;argument type {0} does not conform to vararg element type {1}&quot;}, {&quot;compiler.misc.varargs.clash.with&quot;, &quot;{0} in {1} overrides {2} in {3}&quot;}, {&quot;compiler.misc.varargs.implement&quot;, &quot;{0} in {1} implements {2} in {3}&quot;}, {&quot;compiler.misc.varargs.override&quot;, &quot;{0} in {1} overrides {2} in {3}&quot;}, {&quot;compiler.misc.varargs.trustme.on.non.varargs.meth&quot;, &quot;Method {0} is not a varargs method.&quot;}, {&quot;compiler.misc.varargs.trustme.on.reifiable.varargs&quot;, &quot;Varargs element type {0} is reifiable.&quot;}, {&quot;compiler.misc.varargs.trustme.on.virtual.varargs&quot;, &quot;Instance method {0} is not final.&quot;}, {&quot;compiler.misc.verbose.checking.attribution&quot;, &quot;[checking {0}]&quot;}, {&quot;compiler.misc.verbose.classpath&quot;, &quot;[search path for class files: {0}]&quot;}, {&quot;compiler.misc.verbose.loading&quot;, &quot;[loading {0}]&quot;}, {&quot;compiler.misc.verbose.parsing.done&quot;, &quot;[parsing completed {0}ms]&quot;}, {&quot;compiler.misc.verbose.parsing.started&quot;, &quot;[parsing started {0}]&quot;}, {&quot;compiler.misc.verbose.retro&quot;, &quot;[retrofitting {0}]&quot;}, {&quot;compiler.misc.verbose.retro.with&quot;, &quot;\tretrofitting {0} with {1}&quot;}, {&quot;compiler.misc.verbose.retro.with.list&quot;, &quot;\tretrofitting {0} with type parameters {1}, supertype {2}, interfaces {3}&quot;}, {&quot;compiler.misc.verbose.sourcepath&quot;, &quot;[search path for source files: {0}]&quot;}, {&quot;compiler.misc.verbose.total&quot;, &quot;[total {0}ms]&quot;}, {&quot;compiler.misc.verbose.wrote.file&quot;, &quot;[wrote {0}]&quot;}, {&quot;compiler.misc.version.not.available&quot;, &quot;(version info not available)&quot;}, {&quot;compiler.misc.where.captured&quot;, &quot;{0} extends {1} super: {2} from capture of {3}&quot;}, {&quot;compiler.misc.where.captured.1&quot;, &quot;{0} extends {1} from capture of {3}&quot;}, {&quot;compiler.misc.where.description.captured&quot;, &quot;where {0} is a fresh type-variable:&quot;}, {&quot;compiler.misc.where.description.captured.1&quot;, &quot;where {0} are fresh type-variables:&quot;}, {&quot;compiler.misc.where.description.intersection&quot;, &quot;where {0} is an intersection type:&quot;}, {&quot;compiler.misc.where.description.intersection.1&quot;, &quot;where {0} are intersection types:&quot;}, {&quot;compiler.misc.where.description.typevar&quot;, &quot;where {0} is a type-variable:&quot;}, {&quot;compiler.misc.where.description.typevar.1&quot;, &quot;where {0} are type-variables:&quot;}, {&quot;compiler.misc.where.intersection&quot;, &quot;{0} extends {1}&quot;}, {&quot;compiler.misc.where.typevar&quot;, &quot;{0} extends {1} declared in {2} {3}&quot;}, {&quot;compiler.misc.where.typevar.1&quot;, &quot;{0} declared in {2} {3}&quot;}, {&quot;compiler.misc.wrong.version&quot;, &quot;class file has wrong version {0}.{1}, should be {2}.{3}&quot;}, {&quot;compiler.misc.x.print.processor.info&quot;, &quot;Processor {0} matches {1} and returns {2}.&quot;}, {&quot;compiler.misc.x.print.rounds&quot;, &quot;Round {0}:\n\tinput files: {1}\n\tannotations: {2}\n\tlast round: {3}&quot;}, {&quot;compiler.note.deprecated.filename&quot;, &quot;{0} uses or overrides a deprecated API.&quot;}, {&quot;compiler.note.deprecated.filename.additional&quot;, &quot;{0} has additional uses or overrides of a deprecated API.&quot;}, {&quot;compiler.note.deprecated.plural&quot;, &quot;Some input files use or override a deprecated API.&quot;}, {&quot;compiler.note.deprecated.plural.additional&quot;, &quot;Some input files additionally use or override a deprecated API.&quot;}, {&quot;compiler.note.deprecated.recompile&quot;, &quot;Recompile with -Xlint:deprecation for details.&quot;}, {&quot;compiler.note.note&quot;, &quot;Note: &quot;}, {&quot;compiler.note.proc.messager&quot;, &quot;{0}&quot;}, {&quot;compiler.note.sunapi.filename&quot;, &quot;{0} uses internal proprietary API that may be removed in a future release.&quot;}, {&quot;compiler.note.sunapi.filename.additional&quot;, &quot;{0} uses additional internal proprietary API that may be removed in a future release.&quot;}, {&quot;compiler.note.sunapi.plural&quot;, &quot;Some input files use internal proprietary API that may be removed in a future release.&quot;}, {&quot;compiler.note.sunapi.plural.additional&quot;, &quot;Some input files additionally use internal proprietary API that may be removed in a future release.&quot;}, {&quot;compiler.note.sunapi.recompile&quot;, &quot;Recompile with -Xlint:sunapi for details.&quot;}, {&quot;compiler.note.unchecked.filename&quot;, &quot;{0} uses unchecked or unsafe operations.&quot;}, {&quot;compiler.note.unchecked.filename.additional&quot;, &quot;{0} has additional unchecked or unsafe operations.&quot;}, {&quot;compiler.note.unchecked.plural&quot;, &quot;Some input files use unchecked or unsafe operations.&quot;}, {&quot;compiler.note.unchecked.plural.additional&quot;, &quot;Some input files additionally use unchecked or unsafe operations.&quot;}, {&quot;compiler.note.unchecked.recompile&quot;, &quot;Recompile with -Xlint:unchecked for details.&quot;}, {&quot;compiler.warn.annotation.method.not.found&quot;, &quot;Cannot find annotation method \&#39;\&#39;{1}()\&#39;\&#39; in type \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;compiler.warn.annotation.method.not.found.reason&quot;, &quot;Cannot find annotation method \&#39;\&#39;{1}()\&#39;\&#39; in type \&#39;\&#39;{0}\&#39;\&#39;: {2}&quot;}, {&quot;compiler.warn.assert.as.identifier&quot;, &quot;as of release 1.4, \&#39;\&#39;assert\&#39;\&#39; is a keyword, and may not be used as an identifier\n(use -source 1.4 or higher to use \&#39;\&#39;assert\&#39;\&#39; as a keyword)&quot;}, {&quot;compiler.warn.big.major.version&quot;, &quot;{0}: major version {1} is newer than {2}, the highest major version supported by this compiler.\nIt is recommended that the compiler be upgraded.&quot;}, {&quot;compiler.warn.constant.SVUID&quot;, &quot;serialVersionUID must be constant in class {0}&quot;}, {&quot;compiler.warn.diamond.redundant.args&quot;, &quot;redundant type arguments in new expression (use diamond operator instead).&quot;}, {&quot;compiler.warn.diamond.redundant.args.1&quot;, &quot;redundant type arguments in new expression (use diamond operator instead).\nexplicit: {0}\ninferred: {1}&quot;}, {&quot;compiler.warn.dir.path.element.not.found&quot;, &quot;bad path element \&quot;{0}\&quot;: no such directory&quot;}, {&quot;compiler.warn.div.zero&quot;, &quot;division by zero&quot;}, {&quot;compiler.warn.empty.if&quot;, &quot;empty statement after if&quot;}, {&quot;compiler.warn.enum.as.identifier&quot;, &quot;as of release 5, \&#39;\&#39;enum\&#39;\&#39; is a keyword, and may not be used as an identifier\n(use -source 5 or higher to use \&#39;\&#39;enum\&#39;\&#39; as a keyword)&quot;}, {&quot;compiler.warn.finally.cannot.complete&quot;, &quot;finally clause cannot complete normally&quot;}, {&quot;compiler.warn.forward.ref&quot;, &quot;reference to variable \&#39;\&#39;{0}\&#39;\&#39; before it has been initialized&quot;}, {&quot;compiler.warn.future.attr&quot;, &quot;{0} attribute introduced in version {1}.{2} class files is ignored in version {3}.{4} class files&quot;}, {&quot;compiler.warn.has.been.deprecated&quot;, &quot;{0} in {1} has been deprecated&quot;}, {&quot;compiler.warn.illegal.char.for.encoding&quot;, &quot;unmappable character for encoding {0}&quot;}, {&quot;compiler.warn.improper.SVUID&quot;, &quot;serialVersionUID must be declared static final in class {0}&quot;}, {&quot;compiler.warn.inexact.non-varargs.call&quot;, &quot;non-varargs call of varargs method with inexact argument type for last parameter;\ncast to {0} for a varargs call\ncast to {1} for a non-varargs call and to suppress this warning&quot;}, {&quot;compiler.warn.invalid.archive.file&quot;, &quot;Unexpected file on path: {0}&quot;}, {&quot;compiler.warn.lintOption&quot;, &quot;[{0}] &quot;}, {&quot;compiler.warn.long.SVUID&quot;, &quot;serialVersionUID must be of type long in class {0}&quot;}, {&quot;compiler.warn.missing.SVUID&quot;, &quot;serializable class {0} has no definition of serialVersionUID&quot;}, {&quot;compiler.warn.missing.deprecated.annotation&quot;, &quot;deprecated item is not annotated with @Deprecated&quot;}, {&quot;compiler.warn.override.bridge&quot;, &quot;{0}; overridden method is a bridge method&quot;}, {&quot;compiler.warn.override.unchecked.ret&quot;, &quot;{0}\nreturn type requires unchecked conversion from {1} to {2}&quot;}, {&quot;compiler.warn.override.unchecked.thrown&quot;, &quot;{0}\noverridden method does not throw {1}&quot;}, {&quot;compiler.warn.override.varargs.extra&quot;, &quot;{0}; overriding method is missing \&#39;\&#39;...\&#39;\&#39;&quot;}, {&quot;compiler.warn.override.varargs.missing&quot;, &quot;{0}; overridden method has no \&#39;\&#39;...\&#39;\&#39;&quot;}, {&quot;compiler.warn.path.element.not.found&quot;, &quot;bad path element \&quot;{0}\&quot;: no such file or directory&quot;}, {&quot;compiler.warn.pkg-info.already.seen&quot;, &quot;a package-info.java file has already been seen for package {0}&quot;}, {&quot;compiler.warn.position.overflow&quot;, &quot;Position encoding overflows at line {0}&quot;}, {&quot;compiler.warn.possible.fall-through.into.case&quot;, &quot;possible fall-through into case&quot;}, {&quot;compiler.warn.prob.found.req&quot;, &quot;{0}\nrequired: {2}\nfound:    {1}&quot;}, {&quot;compiler.warn.proc.annotations.without.processors&quot;, &quot;No processor claimed any of these annotations: {0}&quot;}, {&quot;compiler.warn.proc.file.create.last.round&quot;, &quot;File for type \&#39;\&#39;{0}\&#39;\&#39; created in the last round will not be subject to annotation processing.&quot;}, {&quot;compiler.warn.proc.file.reopening&quot;, &quot;Attempt to create a file for \&#39;\&#39;{0}\&#39;\&#39; multiple times&quot;}, {&quot;compiler.warn.proc.illegal.file.name&quot;, &quot;Cannot create file for illegal name \&#39;\&#39;{0}\&#39;\&#39;.&quot;}, {&quot;compiler.warn.proc.malformed.supported.string&quot;, &quot;Malformed string \&#39;\&#39;{0}\&#39;\&#39; for a supported annotation type returned by processor \&#39;\&#39;{1}\&#39;\&#39;&quot;}, {&quot;compiler.warn.proc.messager&quot;, &quot;{0}&quot;}, {&quot;compiler.warn.proc.package.does.not.exist&quot;, &quot;package {0} does not exist&quot;}, {&quot;compiler.warn.proc.proc-only.requested.no.procs&quot;, &quot;Annotation processing without compilation requested but no processors were found.&quot;}, {&quot;compiler.warn.proc.processor.incompatible.source.version&quot;, &quot;Supported source version \&#39;\&#39;{0}\&#39;\&#39; from annotation processor \&#39;\&#39;{1}\&#39;\&#39; less than -source \&#39;\&#39;{2}\&#39;\&#39;&quot;}, {&quot;compiler.warn.proc.suspicious.class.name&quot;, &quot;Creating file for a type whose name ends in {1}: \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;compiler.warn.proc.type.already.exists&quot;, &quot;A file for type \&#39;\&#39;{0}\&#39;\&#39; already exists on the sourcepath or classpath&quot;}, {&quot;compiler.warn.proc.type.recreate&quot;, &quot;Attempt to create a file for type \&#39;\&#39;{0}\&#39;\&#39; multiple times&quot;}, {&quot;compiler.warn.proc.unclosed.type.files&quot;, &quot;Unclosed files for the types \&#39;\&#39;{0}\&#39;\&#39;; these types will not undergo annotation processing&quot;}, {&quot;compiler.warn.proc.unmatched.processor.options&quot;, &quot;The following options were not recognized by any processor: \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;compiler.warn.proc.use.implicit&quot;, &quot;Implicitly compiled files were not subject to annotation processing.\nUse -implicit to specify a policy for implicit compilation.&quot;}, {&quot;compiler.warn.proc.use.proc.or.implicit&quot;, &quot;Implicitly compiled files were not subject to annotation processing.\nUse -proc:none to disable annotation processing or -implicit to specify a policy for implicit compilation.&quot;}, {&quot;compiler.warn.raw.class.use&quot;, &quot;found raw type: {0}\nmissing type arguments for generic class {1}&quot;}, {&quot;compiler.warn.redundant.cast&quot;, &quot;redundant cast to {0}&quot;}, {&quot;compiler.warn.self.ref&quot;, &quot;self-reference in initializer of variable \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;compiler.warn.source.no.bootclasspath&quot;, &quot;bootstrap class path not set in conjunction with -source {0}&quot;}, {&quot;compiler.warn.static.not.qualified.by.type&quot;, &quot;static {0} should be qualified by type name, {1}, instead of by an expression&quot;}, {&quot;compiler.warn.sun.proprietary&quot;, &quot;{0} is internal proprietary API and may be removed in a future release&quot;}, {&quot;compiler.warn.synthetic.name.conflict&quot;, &quot;the symbol {0} conflicts with a compiler-synthesized symbol in {1}&quot;}, {&quot;compiler.warn.try.explicit.close.call&quot;, &quot;explicit call to close() on an auto-closeable resource&quot;}, {&quot;compiler.warn.try.resource.not.referenced&quot;, &quot;auto-closeable resource {0} is never referenced in body of corresponding try statement&quot;}, {&quot;compiler.warn.try.resource.throws.interrupted.exc&quot;, &quot;auto-closeable resource {0} has a member method close() that could throw InterruptedException&quot;}, {&quot;compiler.warn.unchecked.assign&quot;, &quot;unchecked assignment: {0} to {1}&quot;}, {&quot;compiler.warn.unchecked.assign.to.var&quot;, &quot;unchecked assignment to variable {0} as member of raw type {1}&quot;}, {&quot;compiler.warn.unchecked.call.mbr.of.raw.type&quot;, &quot;unchecked call to {0} as a member of the raw type {1}&quot;}, {&quot;compiler.warn.unchecked.cast.to.type&quot;, &quot;unchecked cast to type {0}&quot;}, {&quot;compiler.warn.unchecked.generic.array.creation&quot;, &quot;unchecked generic array creation for varargs parameter of type {0}&quot;}, {&quot;compiler.warn.unchecked.meth.invocation.applied&quot;, &quot;unchecked method invocation: {0} {1} in {4} {5} is applied to given types\nrequired: {2}\nfound: {3}&quot;}, {&quot;compiler.warn.unchecked.varargs.non.reifiable.type&quot;, &quot;Possible heap pollution from parameterized vararg type {0}&quot;}, {&quot;compiler.warn.unexpected.archive.file&quot;, &quot;Unexpected extension for archive file: {0}&quot;}, {&quot;compiler.warn.unknown.enum.constant&quot;, &quot;unknown enum constant {1}.{2}&quot;}, {&quot;compiler.warn.unknown.enum.constant.reason&quot;, &quot;unknown enum constant {1}.{2}\nreason: {3}&quot;}, {&quot;compiler.warn.unreachable.catch&quot;, &quot;unreachable catch clause\nthrown type {0} has already been caught&quot;}, {&quot;compiler.warn.unreachable.catch.1&quot;, &quot;unreachable catch clause\nthrown types {0} have already been caught&quot;}, {&quot;compiler.warn.varargs.redundant.trustme.anno&quot;, &quot;Redundant {0} annotation. {1}&quot;}, {&quot;compiler.warn.varargs.unsafe.use.varargs.param&quot;, &quot;Varargs method could cause heap pollution from non-reifiable varargs parameter {0}&quot;}, {&quot;compiler.warn.warning&quot;, &quot;warning: &quot;}};
<i>16</i>&nbsp;    }
<i>17</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2014-12-21 15:54</div>
</div>
</body>
</html>
