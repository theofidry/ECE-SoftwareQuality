


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: compiler_zh_CN</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.tools.javac.resources</a> ]
</div>

<h1>Coverage Summary for Class: compiler_zh_CN (com.sun.tools.javac.resources)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">compiler_zh_CN</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;//
<i>2</i>&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
<i>3</i>&nbsp;// (powered by Fernflower decompiler)
<i>4</i>&nbsp;//
<b class="nc"><i>5</i>&nbsp;</b>
<i>6</i>&nbsp;package com.sun.tools.javac.resources;
<b class="nc"><i>7</i>&nbsp;</b>
<i>8</i>&nbsp;import java.util.ListResourceBundle;
<i>9</i>&nbsp;
<i>10</i>&nbsp;public final class compiler_zh_CN extends ListResourceBundle {
<i>11</i>&nbsp;    public compiler_zh_CN() {
<i>12</i>&nbsp;    }
<i>13</i>&nbsp;
<i>14</i>&nbsp;    protected final Object[][] getContents() {
<i>15</i>&nbsp;        return new Object[][]{{&quot;compiler.err.abstract.cant.be.accessed.directly&quot;, &quot;无法直接访问{2}中的抽象{0} {1}&quot;}, {&quot;compiler.err.abstract.cant.be.instantiated&quot;, &quot;{0}是抽象的; 无法实例化&quot;}, {&quot;compiler.err.abstract.meth.cant.have.body&quot;, &quot;抽象方法不能有主体&quot;}, {&quot;compiler.err.already.annotated&quot;, &quot;{0} {1}已进行注释&quot;}, {&quot;compiler.err.already.defined&quot;, &quot;已在{2} {3}中定义了{0} {1}&quot;}, {&quot;compiler.err.already.defined.in.clinit&quot;, &quot;已在{3} {4}的{2}中定义了{0} {1}&quot;}, {&quot;compiler.err.already.defined.single.import&quot;, &quot;已在 single-type 导入中定义{0}&quot;}, {&quot;compiler.err.already.defined.static.single.import&quot;, &quot;已在静态 single-type 导入中定义{0}&quot;}, {&quot;compiler.err.already.defined.this.unit&quot;, &quot;已在该编译单元中定义{0}&quot;}, {&quot;compiler.err.annotation.missing.default.value&quot;, &quot;对于属性{1}, 注释{0}缺少值&quot;}, {&quot;compiler.err.annotation.missing.default.value.1&quot;, &quot;对于属性{1}, 注释{0}缺少值&quot;}, {&quot;compiler.err.annotation.not.valid.for.type&quot;, &quot;对于类型为{0}的值, 注释无效&quot;}, {&quot;compiler.err.annotation.type.not.applicable&quot;, &quot;注释类型不适用于该类型的声明&quot;}, {&quot;compiler.err.annotation.value.must.be.annotation&quot;, &quot;注释值必须为注释&quot;}, {&quot;compiler.err.annotation.value.must.be.class.literal&quot;, &quot;注释值必须为类文字&quot;}, {&quot;compiler.err.annotation.value.must.be.name.value&quot;, &quot;注释值必须采用 \&#39;\&#39;name=value\&#39;\&#39; 格式&quot;}, {&quot;compiler.err.annotation.value.not.allowable.type&quot;, &quot;注释值不是允许的类型&quot;}, {&quot;compiler.err.annotations.not.supported.in.source&quot;, &quot;-source {0} 中不支持注释\n(请使用 -source 5 或更高版本以启用注释)&quot;}, {&quot;compiler.err.anon.class.impl.intf.no.args&quot;, &quot;匿名类实现接口; 不能有参数&quot;}, {&quot;compiler.err.anon.class.impl.intf.no.qual.for.new&quot;, &quot;匿名类实现接口; 不能有限定符 - 对于新&quot;}, {&quot;compiler.err.anon.class.impl.intf.no.typeargs&quot;, &quot;匿名类实现接口; 不能具有类型参数&quot;}, {&quot;compiler.err.array.and.varargs&quot;, &quot;无法在{2}中同时声明{0}和{1}&quot;}, {&quot;compiler.err.array.dimension.missing&quot;, &quot;缺少数组维&quot;}, {&quot;compiler.err.array.req.but.found&quot;, &quot;需要数组, 但找到{0}&quot;}, {&quot;compiler.err.assert.as.identifier&quot;, &quot;从发行版 1.4 开始, \&#39;\&#39;assert\&#39;\&#39; 是一个关键字, 但不能用作标识符\n(请使用 -source 1.3 或更低版本以将 \&#39;\&#39;assert\&#39;\&#39; 用作标识符)&quot;}, {&quot;compiler.err.assignment.from.super-bound&quot;, &quot;通过通配符 {0} 分配&quot;}, {&quot;compiler.err.assignment.to.extends-bound&quot;, &quot;分配给通配符 {0}&quot;}, {&quot;compiler.err.attribute.value.must.be.constant&quot;, &quot;属性值必须为常量&quot;}, {&quot;compiler.err.break.outside.switch.loop&quot;, &quot;在 switch 或 loop 外部中断&quot;}, {&quot;compiler.err.call.must.be.first.stmt.in.ctor&quot;, &quot;对{0}的调用必须是构造器中的第一个语句&quot;}, {&quot;compiler.err.call.to.super.not.allowed.in.enum.ctor&quot;, &quot;在枚举构造器中不允许调用超类&quot;}, {&quot;compiler.err.cannot.create.array.with.diamond&quot;, &quot;无法创建具有 \&#39;\&#39;&lt;&gt;\&#39;\&#39; 的数组&quot;}, {&quot;compiler.err.cannot.create.array.with.type.arguments&quot;, &quot;无法创建具有类型变量的数组&quot;}, {&quot;compiler.err.cant.access&quot;, &quot;无法访问{0}\n{1}&quot;}, {&quot;compiler.err.cant.apply.diamond&quot;, &quot;无法推断{0}的类型参数&quot;}, {&quot;compiler.err.cant.apply.diamond.1&quot;, &quot;无法推断{0}的类型参数;\n原因: {1}&quot;}, {&quot;compiler.err.cant.apply.symbol&quot;, &quot;无法将{4} {5}中的{0} {1}应用到给定类型\n需要: {2}\n找到: {3}&quot;}, {&quot;compiler.err.cant.apply.symbol.1&quot;, &quot;无法将{4} {5}中的{0} {1}应用到给定类型;\n需要: {2}\n找到: {3}\n原因: {6}&quot;}, {&quot;compiler.err.cant.apply.symbols&quot;, &quot;对于{1}({2}), 找不到合适的{0}&quot;}, {&quot;compiler.err.cant.assign.val.to.final.var&quot;, &quot;无法为最终变量{0}分配值&quot;}, {&quot;compiler.err.cant.deref&quot;, &quot;无法取消引用{0}&quot;}, {&quot;compiler.err.cant.extend.intf.annotation&quot;, &quot;对于 @interfaces, 不允许 \&#39;\&#39;extends\&#39;\&#39;&quot;}, {&quot;compiler.err.cant.inherit.diff.arg&quot;, &quot;无法使用以下不同的参数继承{0}: &lt;{1}&gt; 和 &lt;{2}&gt;&quot;}, {&quot;compiler.err.cant.inherit.from.final&quot;, &quot;无法从最终{0}进行继承&quot;}, {&quot;compiler.err.cant.read.file&quot;, &quot;无法读取: {0}&quot;}, {&quot;compiler.err.cant.ref.before.ctor.called&quot;, &quot;无法在调用超类型构造器之前引用{0}&quot;}, {&quot;compiler.err.cant.resolve&quot;, &quot;找不到符号\n符号: {0} {1}&quot;}, {&quot;compiler.err.cant.resolve.args&quot;, &quot;找不到符号\n符号: {0} {1}({3})&quot;}, {&quot;compiler.err.cant.resolve.args.params&quot;, &quot;找不到符号\n符号: {0} &lt;{2}&gt;{1}({3})&quot;}, {&quot;compiler.err.cant.resolve.location&quot;, &quot;找不到符号\n符号:   {0} {1}\n位置: {4}&quot;}, {&quot;compiler.err.cant.resolve.location.args&quot;, &quot;找不到符号\n符号:   {0} {1}({3})\n位置: {4}&quot;}, {&quot;compiler.err.cant.resolve.location.args.params&quot;, &quot;找不到符号\n符号:   {0} &lt;{2}&gt;{1}({3})\n位置: {4}&quot;}, {&quot;compiler.err.cant.ret.val.from.meth.decl.void&quot;, &quot;对于结果类型为空的方法, 无法返回值&quot;}, {&quot;compiler.err.cant.select.static.class.from.param.type&quot;, &quot;无法从参数化的类型中选择静态类&quot;}, {&quot;compiler.err.catch.without.try&quot;, &quot;有 \&#39;\&#39;catch\&#39;\&#39;, 但是没有 \&#39;\&#39;try\&#39;\&#39;&quot;}, {&quot;compiler.err.clash.with.pkg.of.same.name&quot;, &quot;{0} {1}与带有相同名称的程序包冲突&quot;}, {&quot;compiler.err.class.cant.write&quot;, &quot;写入{0}时出错: {1}&quot;}, {&quot;compiler.err.class.public.should.be.in.file&quot;, &quot;类{0}是公共的, 应在名为 {0}.java 的文件中声明&quot;}, {&quot;compiler.err.concrete.inheritance.conflict&quot;, &quot;{1}中的方法{0}和{3}中的方法{2}是使用相同的签名继承的&quot;}, {&quot;compiler.err.const.expr.req&quot;, &quot;需要常量表达式&quot;}, {&quot;compiler.err.cont.outside.loop&quot;, &quot;continue 在 loop 外部&quot;}, {&quot;compiler.err.cyclic.annotation.element&quot;, &quot;循环注释元素类型&quot;}, {&quot;compiler.err.cyclic.inheritance&quot;, &quot;涉及{0}的循环继承&quot;}, {&quot;compiler.err.default.allowed.in.intf.annotation.member&quot;, &quot;仅在 @interface 成员中允许使用默认值&quot;}, {&quot;compiler.err.diamond.not.supported.in.source&quot;, &quot;-source {0} 中不支持 diamond 运算符\n(请使用 -source 7 或更高版本以启用 diamond 运算符)&quot;}, {&quot;compiler.err.does.not.override.abstract&quot;, &quot;{0}不是抽象的, 并且未覆盖{2}中的抽象方法{1}&quot;}, {&quot;compiler.err.doesnt.exist&quot;, &quot;程序包{0}不存在&quot;}, {&quot;compiler.err.dot.class.expected&quot;, &quot;需要 \&#39;\&#39;.class\&#39;\&#39;&quot;}, {&quot;compiler.err.duplicate.annotation&quot;, &quot;注释重复&quot;}, {&quot;compiler.err.duplicate.annotation.member.value&quot;, &quot;{1}中的注释成员值{0}重复&quot;}, {&quot;compiler.err.duplicate.case.label&quot;, &quot;case 标签重复&quot;}, {&quot;compiler.err.duplicate.class&quot;, &quot;类重复: {0}&quot;}, {&quot;compiler.err.duplicate.default.label&quot;, &quot;default 标签重复&quot;}, {&quot;compiler.err.else.without.if&quot;, &quot;有 \&#39;\&#39;if\&#39;\&#39;, 但是没有 \&#39;\&#39;else\&#39;\&#39;&quot;}, {&quot;compiler.err.empty.char.lit&quot;, &quot;空字符文字&quot;}, {&quot;compiler.err.encl.class.required&quot;, &quot;需要包含{0}的封闭实例&quot;}, {&quot;compiler.err.enum.annotation.must.be.enum.constant&quot;, &quot;枚举注释值必须是枚举常量&quot;}, {&quot;compiler.err.enum.as.identifier&quot;, &quot;从发行版 5 开始, \&#39;\&#39;enum\&#39;\&#39; 为关键字, 而不用作标识符\n(请使用 -source 1.4 或更低版本以将 \&#39;\&#39;enum\&#39;\&#39; 用作标识符)&quot;}, {&quot;compiler.err.enum.cant.be.instantiated&quot;, &quot;无法实例化枚举类型&quot;}, {&quot;compiler.err.enum.label.must.be.unqualified.enum&quot;, &quot;枚举 switch case 标签必须为枚举常量的非限定名称&quot;}, {&quot;compiler.err.enum.no.finalize&quot;, &quot;枚举不能有 finalize 方法&quot;}, {&quot;compiler.err.enum.no.subclassing&quot;, &quot;类无法直接扩展 java.lang.Enum&quot;}, {&quot;compiler.err.enum.types.not.extensible&quot;, &quot;枚举类型不可继承&quot;}, {&quot;compiler.err.enums.must.be.static&quot;, &quot;只有在静态上下文中才允许使用枚举声明&quot;}, {&quot;compiler.err.enums.not.supported.in.source&quot;, &quot;-source {0} 中不支持枚举\n(请使用 -source 5 或更高版本以启用枚举)&quot;}, {&quot;compiler.err.error&quot;, &quot;错误: &quot;}, {&quot;compiler.err.error.reading.file&quot;, &quot;读取{0}时出错; {1}&quot;}, {&quot;compiler.err.except.already.caught&quot;, &quot;已捕获到异常错误{0}&quot;}, {&quot;compiler.err.except.never.thrown.in.try&quot;, &quot;在相应的 try 语句主体中不能抛出异常错误{0}&quot;}, {&quot;compiler.err.expected&quot;, &quot;需要{0}&quot;}, {&quot;compiler.err.expected2&quot;, &quot;需要{0}或{1}&quot;}, {&quot;compiler.err.expected3&quot;, &quot;需要{0}, {1}或{2}&quot;}, {&quot;compiler.err.final.parameter.may.not.be.assigned&quot;, &quot;不能分配最终参数{0}&quot;}, {&quot;compiler.err.finally.without.try&quot;, &quot;有 \&#39;\&#39;finally\&#39;\&#39;, 但是没有 \&#39;\&#39;try\&#39;\&#39;&quot;}, {&quot;compiler.err.foreach.not.applicable.to.type&quot;, &quot;for-each 不适用于表达式类型\n要求: {1}\n找到:    {0}&quot;}, {&quot;compiler.err.foreach.not.supported.in.source&quot;, &quot;-source {0} 中不支持 for-each 循环\n(请使用 -source 5 或更高版本以启用 for-each 循环)&quot;}, {&quot;compiler.err.fp.number.too.large&quot;, &quot;浮点数过大&quot;}, {&quot;compiler.err.fp.number.too.small&quot;, &quot;浮点数过小&quot;}, {&quot;compiler.err.generic.array.creation&quot;, &quot;创建泛型数组&quot;}, {&quot;compiler.err.generic.throwable&quot;, &quot;泛型类不能扩展 java.lang.Throwable&quot;}, {&quot;compiler.err.generics.not.supported.in.source&quot;, &quot;-source {0} 中不支持泛型\n(请使用 -source 5 或更高版本以启用泛型)&quot;}, {&quot;compiler.err.icls.cant.have.static.decl&quot;, &quot;内部类{0}中的静态声明非法\n修饰符 \&#39;\&#39;static\&#39;\&#39; 仅允许在常量变量声明中使用&quot;}, {&quot;compiler.err.illegal.char&quot;, &quot;非法字符: \\{0}&quot;}, {&quot;compiler.err.illegal.char.for.encoding&quot;, &quot;编码{0}的不可映射字符&quot;}, {&quot;compiler.err.illegal.combination.of.modifiers&quot;, &quot;非法的修饰符组合: {0}和{1}&quot;}, {&quot;compiler.err.illegal.enum.static.ref&quot;, &quot;初始化程序中对静态字段的引用不合法&quot;}, {&quot;compiler.err.illegal.esc.char&quot;, &quot;非法转义符&quot;}, {&quot;compiler.err.illegal.forward.ref&quot;, &quot;非法前向引用&quot;}, {&quot;compiler.err.illegal.generic.type.for.instof&quot;, &quot;instanceof 的泛型类型不合法&quot;}, {&quot;compiler.err.illegal.initializer.for.type&quot;, &quot;{0}的初始化程序不合法&quot;}, {&quot;compiler.err.illegal.line.end.in.char.lit&quot;, &quot;字符文字的行结尾不合法&quot;}, {&quot;compiler.err.illegal.nonascii.digit&quot;, &quot;非法的非 ASCII 数字&quot;}, {&quot;compiler.err.illegal.qual.not.icls&quot;, &quot;非法限定符; {0}不是内部类&quot;}, {&quot;compiler.err.illegal.self.ref&quot;, &quot;初始化程序中存在自引用&quot;}, {&quot;compiler.err.illegal.start.of.expr&quot;, &quot;非法的表达式开始&quot;}, {&quot;compiler.err.illegal.start.of.type&quot;, &quot;非法的类型开始&quot;}, {&quot;compiler.err.illegal.underscore&quot;, &quot;非法下划线&quot;}, {&quot;compiler.err.illegal.unicode.esc&quot;, &quot;非法的 Unicode 转义&quot;}, {&quot;compiler.err.import.requires.canonical&quot;, &quot;导入需要{0}的规范名称&quot;}, {&quot;compiler.err.improperly.formed.type.inner.raw.param&quot;, &quot;类型的格式不正确, 给出了原始类型的类型参数&quot;}, {&quot;compiler.err.improperly.formed.type.param.missing&quot;, &quot;类型的格式不正确, 缺少某些参数&quot;}, {&quot;compiler.err.incomparable.types&quot;, &quot;不可比较的类型: {0}和{1}&quot;}, {&quot;compiler.err.initializer.must.be.able.to.complete.normally&quot;, &quot;初始化程序必须能够正常完成&quot;}, {&quot;compiler.err.int.number.too.large&quot;, &quot;过大的整数: {0}&quot;}, {&quot;compiler.err.internal.error.cant.instantiate&quot;, &quot;内部错误; 无法将位于{1}的{0}实例化为 ({2})&quot;}, {&quot;compiler.err.intf.annotation.cant.have.type.params&quot;, &quot;@interface 不能带有类型参数&quot;}, {&quot;compiler.err.intf.annotation.member.clash&quot;, &quot;@interface 成员与{1}中的方法 \&#39;\&#39;{0}\&#39;\&#39; 冲突&quot;}, {&quot;compiler.err.intf.annotation.members.cant.have.params&quot;, &quot;@interface 成员不能带有参数&quot;}, {&quot;compiler.err.intf.annotation.members.cant.have.type.params&quot;, &quot;@interface 成员不能带有类型参数&quot;}, {&quot;compiler.err.intf.expected.here&quot;, &quot;此处需要接口&quot;}, {&quot;compiler.err.intf.meth.cant.have.body&quot;, &quot;接口方法不能带有主体&quot;}, {&quot;compiler.err.intf.not.allowed.here&quot;, &quot;此处不允许使用接口&quot;}, {&quot;compiler.err.invalid.annotation.member.type&quot;, &quot;注释成员的类型无效&quot;}, {&quot;compiler.err.invalid.binary.number&quot;, &quot;二进制数字中必须包含至少一个二进制数&quot;}, {&quot;compiler.err.invalid.hex.number&quot;, &quot;十六进制数字必须包含至少一位十六进制数&quot;}, {&quot;compiler.err.invalid.inferred.types&quot;, &quot;{0}的推断类型无效; {1}&quot;}, {&quot;compiler.err.invalid.meth.decl.ret.type.req&quot;, &quot;方法声明无效; 需要返回类型&quot;}, {&quot;compiler.err.io.exception&quot;, &quot;读取源文件时出错: {0}&quot;}, {&quot;compiler.err.label.already.in.use&quot;, &quot;标签{0}已使用&quot;}, {&quot;compiler.err.limit.code&quot;, &quot;代码过长&quot;}, {&quot;compiler.err.limit.code.too.large.for.try.stmt&quot;, &quot;try 语句的代码过长&quot;}, {&quot;compiler.err.limit.dimensions&quot;, &quot;数组类型维过多&quot;}, {&quot;compiler.err.limit.locals&quot;, &quot;本地变量过多&quot;}, {&quot;compiler.err.limit.parameters&quot;, &quot;参数过多&quot;}, {&quot;compiler.err.limit.pool&quot;, &quot;常量过多&quot;}, {&quot;compiler.err.limit.pool.in.class&quot;, &quot;类{0}中的常量过多&quot;}, {&quot;compiler.err.limit.stack&quot;, &quot;代码需要过多堆栈&quot;}, {&quot;compiler.err.limit.string&quot;, &quot;常量字符串过长&quot;}, {&quot;compiler.err.limit.string.overflow&quot;, &quot;对于常量池来说, 字符串 \&quot;{0}...\&quot; 的 UTF8 表示过长&quot;}, {&quot;compiler.err.local.enum&quot;, &quot;枚举类型不能为本地类型&quot;}, {&quot;compiler.err.local.var.accessed.from.icls.needs.final&quot;, &quot;从内部类中访问本地变量{0}; 需要被声明为最终类型&quot;}, {&quot;compiler.err.malformed.fp.lit&quot;, &quot;浮点文字的格式错误&quot;}, {&quot;compiler.err.method.does.not.override.superclass&quot;, &quot;方法不会覆盖或实现超类型的方法&quot;}, {&quot;compiler.err.missing.meth.body.or.decl.abstract&quot;, &quot;缺少方法主体, 或声明抽象&quot;}, {&quot;compiler.err.missing.ret.stmt&quot;, &quot;缺少返回语句&quot;}, {&quot;compiler.err.missing.ret.val&quot;, &quot;缺少返回值&quot;}, {&quot;compiler.err.mod.not.allowed.here&quot;, &quot;此处不允许使用修饰符{0}&quot;}, {&quot;compiler.err.multicatch.not.supported.in.source&quot;, &quot;-source {0} 中不支持 multi-catch 语句\n(请使用 -source 7 或更高版本以启用 multi-catch 语句)&quot;}, {&quot;compiler.err.multicatch.parameter.may.not.be.assigned&quot;, &quot;可能未分配 multi-catch 参数{0}&quot;}, {&quot;compiler.err.multicatch.types.must.be.disjoint&quot;, &quot;multi-catch 语句中的替代无法通过子类化关联\n替代{0}是替代{1}的子类&quot;}, {&quot;compiler.err.name.clash.same.erasure&quot;, &quot;名称冲突: {0}和{1}具有相同疑符&quot;}, {&quot;compiler.err.name.clash.same.erasure.no.hide&quot;, &quot;名称冲突: {1} 中的 {0} 和 {3} 中的 {2} 具有相同疑符, 但两者均不隐藏对方&quot;}, {&quot;compiler.err.name.clash.same.erasure.no.override&quot;, &quot;名称冲突: {1}中的{0}和{3}中的{2}具有相同疑符, 但两者均不覆盖对方&quot;}, {&quot;compiler.err.name.clash.same.erasure.no.override.1&quot;, &quot;名称冲突: {1} 中的 {0} 覆盖的方法的疑符与另一个方法的相同, 但两者均不覆盖对方\n第一个方法:  {3} 中的 {2}\n第二个方法: {5} 中的 {4}&quot;}, {&quot;compiler.err.name.reserved.for.internal.use&quot;, &quot;{0}为内部使用保留&quot;}, {&quot;compiler.err.native.meth.cant.have.body&quot;, &quot;本机方法不能带有主体&quot;}, {&quot;compiler.err.neither.conditional.subtype&quot;, &quot;? 的不兼容类型: 两者都不是对方的子类型\n第二个操作数: {0}\n第三个操作数: {1}&quot;}, {&quot;compiler.err.new.not.allowed.in.annotation&quot;, &quot;注释中不允许使用 \&#39;\&#39;new\&#39;\&#39;&quot;}, {&quot;compiler.err.no.annotation.member&quot;, &quot;{1}中没有注释成员{0}&quot;}, {&quot;compiler.err.no.encl.instance.of.type.in.scope&quot;, &quot;作用域中没有类型为{0}的封闭实例&quot;}, {&quot;compiler.err.no.intf.expected.here&quot;, &quot;此处不需要接口&quot;}, {&quot;compiler.err.no.match.entry&quot;, &quot;{0}在{1}的条目中没有匹配项; 需要{2}&quot;}, {&quot;compiler.err.no.superclass&quot;, &quot;{0}不具有超类&quot;}, {&quot;compiler.err.non-static.cant.be.ref&quot;, &quot;无法从静态上下文中引用非静态 {0} {1}&quot;}, {&quot;compiler.err.not.annotation.type&quot;, &quot;{0}不是注释类型&quot;}, {&quot;compiler.err.not.def.access.class.intf.cant.access&quot;, &quot;{1}中的{0}是在不可访问的类或接口中定义的&quot;}, {&quot;compiler.err.not.def.public.cant.access&quot;, &quot;{0}在{1}中不是公共的; 无法从外部程序包中对其进行访问&quot;}, {&quot;compiler.err.not.encl.class&quot;, &quot;不是封闭类: {0}&quot;}, {&quot;compiler.err.not.loop.label&quot;, &quot;不是 loop 标签: {0}&quot;}, {&quot;compiler.err.not.stmt&quot;, &quot;不是语句&quot;}, {&quot;compiler.err.not.within.bounds&quot;, &quot;类型参数{0}不在类型变量{1}的范围内&quot;}, {&quot;compiler.err.operator.cant.be.applied&quot;, &quot;一元运算符 \&#39;\&#39;{0}\&#39;\&#39; 的操作数类型{1}错误&quot;}, {&quot;compiler.err.operator.cant.be.applied.1&quot;, &quot;二元运算符 \&#39;\&#39;{0}\&#39;\&#39; 的操作数类型错误\n第一个类型:  {1}\n第二个类型: {2}&quot;}, {&quot;compiler.err.orphaned&quot;, &quot;孤立的{0}&quot;}, {&quot;compiler.err.override.incompatible.ret&quot;, &quot;{0}\n返回类型{1}与{2}不兼容&quot;}, {&quot;compiler.err.override.meth&quot;, &quot;{0}\n被覆盖的方法为{1}&quot;}, {&quot;compiler.err.override.meth.doesnt.throw&quot;, &quot;{0}\n被覆盖的方法未抛出{1}&quot;}, {&quot;compiler.err.override.static&quot;, &quot;{0}\n覆盖的方法为 static&quot;}, {&quot;compiler.err.override.weaker.access&quot;, &quot;{0}\n正在尝试分配更低的访问权限; 以前为{1}&quot;}, {&quot;compiler.err.pkg.annotations.sb.in.package-info.java&quot;, &quot;程序包注释应在文件 package-info.java 中&quot;}, {&quot;compiler.err.pkg.clashes.with.class.of.same.name&quot;, &quot;程序包{0}与带有相同名称的类冲突&quot;}, {&quot;compiler.err.premature.eof&quot;, &quot;解析时已到达文件结尾&quot;}, {&quot;compiler.err.prob.found.req&quot;, &quot;{0}\n需要: {2}\n找到:    {1}&quot;}, {&quot;compiler.err.prob.found.req.1&quot;, &quot;{0} {3}\n需要: {2}\n找到:    {1}&quot;}, {&quot;compiler.err.proc.bad.config.file&quot;, &quot;服务配置文件不正确, 或构造处理程序对象{0}时抛出异常错误&quot;}, {&quot;compiler.err.proc.cant.access&quot;, &quot;无法访问{0}\n{1}\n有关详细信息, 请参阅以下堆栈跟踪。\n{2}&quot;}, {&quot;compiler.err.proc.cant.access.1&quot;, &quot;无法访问{0}\n{1}&quot;}, {&quot;compiler.err.proc.cant.create.loader&quot;, &quot;无法为注释处理程序{0}创建类加载器&quot;}, {&quot;compiler.err.proc.cant.find.class&quot;, &quot;找不到 \&#39;\&#39;{0}\&#39;\&#39; 的类文件。&quot;}, {&quot;compiler.err.proc.messager&quot;, &quot;{0}&quot;}, {&quot;compiler.err.proc.no.explicit.annotation.processing.requested&quot;, &quot;仅当显式请求注释处理时才接受类名称 \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;compiler.err.proc.no.service&quot;, &quot;找不到服务加载器类。\njava.util.ServiceLoader 或 sun.misc.Service 必须可用。&quot;}, {&quot;compiler.err.proc.processor.bad.option.name&quot;, &quot;处理程序 \&#39;\&#39;{1}\&#39;\&#39; 提供的选项名称 \&#39;\&#39;{0}\&#39;\&#39; 错误&quot;}, {&quot;compiler.err.proc.processor.cant.instantiate&quot;, &quot;无法实例化处理程序 \&#39;\&#39;{0}\&#39;\&#39; 的实例&quot;}, {&quot;compiler.err.proc.processor.constructor.error&quot;, &quot;构造处理程序对象{0}时抛出异常错误&quot;}, {&quot;compiler.err.proc.processor.not.found&quot;, &quot;找不到注释处理程序 \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;compiler.err.proc.processor.wrong.type&quot;, &quot;注释处理程序 \&#39;\&#39;{0}\&#39;\&#39; 未实现 javax.annotation.processing.Processor&quot;}, {&quot;compiler.err.proc.service.problem&quot;, &quot;创建服务加载器以加载处理程序时出错。&quot;}, {&quot;compiler.err.qualified.new.of.static.class&quot;, &quot;限定的新静态类&quot;}, {&quot;compiler.err.recursive.ctor.invocation&quot;, &quot;递归构造器调用&quot;}, {&quot;compiler.err.ref.ambiguous&quot;, &quot;对{0}的引用不明确, {3}中的{1} {2}和{6}中的{4} {5}都匹配&quot;}, {&quot;compiler.err.repeated.annotation.target&quot;, &quot;注释目标重复&quot;}, {&quot;compiler.err.repeated.interface&quot;, &quot;接口重复&quot;}, {&quot;compiler.err.repeated.modifier&quot;, &quot;修饰符重复&quot;}, {&quot;compiler.err.report.access&quot;, &quot;{0}可以在{2}中访问{1}&quot;}, {&quot;compiler.err.ret.outside.meth&quot;, &quot;返回外部方法&quot;}, {&quot;compiler.err.signature.doesnt.match.intf&quot;, &quot;签名与{0}不匹配; 不兼容的接口&quot;}, {&quot;compiler.err.signature.doesnt.match.supertype&quot;, &quot;签名与{0}不匹配; 不兼容的超类型&quot;}, {&quot;compiler.err.source.cant.overwrite.input.file&quot;, &quot;写入源时出错; 无法覆盖输入文件{0}&quot;}, {&quot;compiler.err.stack.sim.error&quot;, &quot;内部错误: {0}中的堆栈 sim 错误&quot;}, {&quot;compiler.err.static.imp.only.classes.and.interfaces&quot;, &quot;仅从类和接口静态导入&quot;}, {&quot;compiler.err.static.import.not.supported.in.source&quot;, &quot;-source {0} 中不支持静态导入声明\n(请使用 -source 5 或更高版本以启用静态导入声明)&quot;}, {&quot;compiler.err.string.const.req&quot;, &quot;需要常量字符串表达式&quot;}, {&quot;compiler.err.string.switch.not.supported.in.source&quot;, &quot;-source {0} 中不支持 switch 中存在字符串\n(请使用 -source 7 或更高版本以允许 switch 中存在字符串)&quot;}, {&quot;compiler.err.synthetic.name.conflict&quot;, &quot;符号{0}与{1}中的 compiler-synthesized 符号冲突&quot;}, {&quot;compiler.err.throws.not.allowed.in.intf.annotation&quot;, &quot;@interface 成员中不允许使用 throws 子句&quot;}, {&quot;compiler.err.try.resource.may.not.be.assigned&quot;, &quot;可能未分配可自动关闭的资源{0}&quot;}, {&quot;compiler.err.try.with.resources.not.supported.in.source&quot;, &quot;-source {0} 中不支持 try-with-resources\n(请使用 -source 7 或更高版本以启用 try-with-resources)&quot;}, {&quot;compiler.err.try.without.catch.finally.or.resource.decls&quot;, &quot;\&#39;\&#39;try\&#39;\&#39; 不带有 \&#39;\&#39;catch\&#39;\&#39;, \&#39;\&#39;finally\&#39;\&#39; 或资源声明&quot;}, {&quot;compiler.err.try.without.catch.or.finally&quot;, &quot;有 \&#39;\&#39;try\&#39;\&#39;, 但是没有 \&#39;\&#39;catch\&#39;\&#39; 或 \&#39;\&#39;finally\&#39;\&#39;&quot;}, {&quot;compiler.err.type.doesnt.take.params&quot;, &quot;类型{0}不带有参数&quot;}, {&quot;compiler.err.type.found.req&quot;, &quot;意外的类型\n需要: {1}\n找到:    {0}&quot;}, {&quot;compiler.err.type.var.cant.be.deref&quot;, &quot;无法从类型变量中进行选择&quot;}, {&quot;compiler.err.type.var.may.not.be.followed.by.other.bounds&quot;, &quot;类型变量后面不能带有其他限制范围&quot;}, {&quot;compiler.err.type.var.more.than.once&quot;, &quot;类型变量{0}在{1}的结果类型中多次出现; 必须对其进行实例化&quot;}, {&quot;compiler.err.type.var.more.than.once.in.result&quot;, &quot;类型变量{0}在{1}的类型中多次出现; 必须对其进行实例化&quot;}, {&quot;compiler.err.types.incompatible.diff.ret&quot;, &quot;类型{0}和{1}不兼容; 两者都定义了{2}, 但却带有不相关的返回类型&quot;}, {&quot;compiler.err.unclosed.char.lit&quot;, &quot;未结束的字符文字&quot;}, {&quot;compiler.err.unclosed.comment&quot;, &quot;未结束的注释&quot;}, {&quot;compiler.err.unclosed.str.lit&quot;, &quot;未结束的字符串文字&quot;}, {&quot;compiler.err.undef.label&quot;, &quot;未定义的标签: {0}&quot;}, {&quot;compiler.err.undetermined.type&quot;, &quot;无法推断{0}的类型参数&quot;}, {&quot;compiler.err.undetermined.type.1&quot;, &quot;无法推断{0}的类型参数;\n原因: {1}&quot;}, {&quot;compiler.err.unexpected.type&quot;, &quot;意外的类型\n需要: {0}\n找到:    {1}&quot;}, {&quot;compiler.err.unreachable.stmt&quot;, &quot;无法访问的语句&quot;}, {&quot;compiler.err.unreported.exception.default.constructor&quot;, &quot;默认构造器中未报告的异常错误{0}&quot;}, {&quot;compiler.err.unreported.exception.implicit.close&quot;, &quot;未报告的异常错误{0}; 必须对其进行捕获或声明以便抛出\n对资源变量 \&#39;\&#39;{1}\&#39;\&#39; 隐式调用 close() 时抛出了异常错误&quot;}, {&quot;compiler.err.unreported.exception.need.to.catch.or.throw&quot;, &quot;未报告的异常错误{0}; 必须对其进行捕获或声明以便抛出&quot;}, {&quot;compiler.err.unsupported.binary.lit&quot;, &quot;-source {0} 中不支持二进制文字\n(请使用 -source 7 或更高版本以启用二进制文字)&quot;}, {&quot;compiler.err.unsupported.cross.fp.lit&quot;, &quot;该 VM 不支持十六进制浮点文字&quot;}, {&quot;compiler.err.unsupported.encoding&quot;, &quot;不支持的编码: {0}&quot;}, {&quot;compiler.err.unsupported.fp.lit&quot;, &quot;-source {0} 中不支持十六进制浮点文字\n(请使用 -source 5 或更高版本以启用十六进制浮点文字)&quot;}, {&quot;compiler.err.unsupported.underscore.lit&quot;, &quot;-source {0} 中不支持文字中存在下划线\n(请使用 -source 7 或更高版本以允许文字中存在下划线)&quot;}, {&quot;compiler.err.var.might.already.be.assigned&quot;, &quot;可能已分配变量{0}&quot;}, {&quot;compiler.err.var.might.be.assigned.in.loop&quot;, &quot;可能在 loop 中分配了变量{0}&quot;}, {&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;可能尚未初始化变量{0}&quot;}, {&quot;compiler.err.varargs.and.old.array.syntax&quot;, &quot;variable-arity 参数中不允许使用传统数组记号&quot;}, {&quot;compiler.err.varargs.invalid.trustme.anno&quot;, &quot;{0} 注释无效。{1}&quot;}, {&quot;compiler.err.varargs.not.supported.in.source&quot;, &quot;-source {0} 中不支持 variable-arity 方法\n(请使用 -source 5 或更高版本以启用 variable-arity 方法)&quot;}, {&quot;compiler.err.void.not.allowed.here&quot;, &quot;此处不允许使用 \&#39;\&#39;空\&#39;\&#39; 类型&quot;}, {&quot;compiler.err.warnings.and.werror&quot;, &quot;发现警告, 但指定了 -Werror&quot;}, {&quot;compiler.err.wrong.number.type.args&quot;, &quot;类型变量数目错误; 需要{0}&quot;}, {&quot;compiler.err.wrong.target.for.polymorphic.signature.definition&quot;, &quot;MethodHandle API 构建需要 -target 7 运行时或更高; 当前为 -target {0}&quot;}, {&quot;compiler.misc.anonymous.class&quot;, &quot;&lt;匿名{0}&gt;&quot;}, {&quot;compiler.misc.arg.length.mismatch&quot;, &quot;实际参数列表和形式参数列表长度不同&quot;}, {&quot;compiler.misc.assignment.from.super-bound&quot;, &quot;从 super-bound 类型{0}进行分配&quot;}, {&quot;compiler.misc.assignment.to.extends-bound&quot;, &quot;到 extends-bound 类型{0}的分配&quot;}, {&quot;compiler.misc.bad.class.file.header&quot;, &quot;错误的类文件: {0}\n{1}\n请删除该文件或确保该文件位于正确的类路径子目录中。&quot;}, {&quot;compiler.misc.bad.class.signature&quot;, &quot;错误的类签名: {0}&quot;}, {&quot;compiler.misc.bad.const.pool.tag&quot;, &quot;错误的常量池标记: {0}&quot;}, {&quot;compiler.misc.bad.const.pool.tag.at&quot;, &quot;错误的常量池标记: {0}, 位于{1}&quot;}, {&quot;compiler.misc.bad.enclosing.class&quot;, &quot;{0}的封闭类错误: {1}&quot;}, {&quot;compiler.misc.bad.enclosing.method&quot;, &quot;类 {0} 的封闭方法属性错误&quot;}, {&quot;compiler.misc.bad.runtime.invisible.param.annotations&quot;, &quot;错误的 RuntimeInvisibleParameterAnnotations 属性: {0}&quot;}, {&quot;compiler.misc.bad.signature&quot;, &quot;错误的签名: {0}&quot;}, {&quot;compiler.misc.bad.source.file.header&quot;, &quot;错误的源文件: {0}\n{1}\n请删除该文件或确保该文件位于正确的源路径子目录中。&quot;}, {&quot;compiler.misc.base.membership&quot;, &quot;您的所有基类都属于我们&quot;}, {&quot;compiler.misc.cant.implement&quot;, &quot;{1}中的{0}无法实现{3}中的{2}&quot;}, {&quot;compiler.misc.cant.override&quot;, &quot;{1}中的{0}无法覆盖{3}中的{2}&quot;}, {&quot;compiler.misc.captured.type&quot;, &quot;CAP#{0}&quot;}, {&quot;compiler.misc.ccf.found.later.version&quot;, &quot;类文件的版本高于预期: {0}&quot;}, {&quot;compiler.misc.ccf.unrecognized.attribute&quot;, &quot;无法识别的属性: {0}&quot;}, {&quot;compiler.misc.clashes.with&quot;, &quot;{1}中的{0}与{3}中的{2}冲突&quot;}, {&quot;compiler.misc.class.file.not.found&quot;, &quot;找不到{0}的类文件&quot;}, {&quot;compiler.misc.class.file.wrong.class&quot;, &quot;类文件包含错误的类: {0}&quot;}, {&quot;compiler.misc.count.error&quot;, &quot;{0} 个错误&quot;}, {&quot;compiler.misc.count.error.plural&quot;, &quot;{0} 个错误&quot;}, {&quot;compiler.misc.count.warn&quot;, &quot;{0} 个警告&quot;}, {&quot;compiler.misc.count.warn.plural&quot;, &quot;{0} 个警告&quot;}, {&quot;compiler.misc.diamond&quot;, &quot;{0}&lt;&gt;&quot;}, {&quot;compiler.misc.diamond.and.anon.class&quot;, &quot;无法将 \&#39;\&#39;&lt;&gt;\&#39;\&#39; 与匿名内部类一起使用&quot;}, {&quot;compiler.misc.diamond.and.explicit.params&quot;, &quot;不能将 \&#39;\&#39;&lt;&gt;\&#39;\&#39; 与构造器的显式类型参数一起使用&quot;}, {&quot;compiler.misc.diamond.non.generic&quot;, &quot;无法将 \&#39;\&#39;&lt;&gt;\&#39;\&#39; 与非泛型类{0}一起使用&quot;}, {&quot;compiler.misc.explicit.param.do.not.conform.to.bounds&quot;, &quot;显式类型参数{0}不符合声明的范围{1}&quot;}, {&quot;compiler.misc.fatal.err.cant.close.loader&quot;, &quot;致命错误: 无法关闭注释处理程序的类加载器&quot;}, {&quot;compiler.misc.fatal.err.cant.locate.ctor&quot;, &quot;致命错误: 找不到{0}的构造器&quot;}, {&quot;compiler.misc.fatal.err.cant.locate.field&quot;, &quot;致命错误: 找不到字段{0}&quot;}, {&quot;compiler.misc.fatal.err.cant.locate.meth&quot;, &quot;致命错误: 找不到方法{0}&quot;}, {&quot;compiler.misc.fatal.err.no.java.lang&quot;, &quot;致命错误: 在类路径或引导类路径中找不到程序包 java.lang&quot;}, {&quot;compiler.misc.file.does.not.contain.package&quot;, &quot;文件不包含程序包{0}&quot;}, {&quot;compiler.misc.file.doesnt.contain.class&quot;, &quot;文件不包含类{0}&quot;}, {&quot;compiler.misc.illegal.start.of.class.file&quot;, &quot;非法的类文件开始&quot;}, {&quot;compiler.misc.inaccessible.varargs.type&quot;, &quot;形式 varargs 元素类型{0}无法从 {1} {2} 进行访问&quot;}, {&quot;compiler.misc.inapplicable.method&quot;, &quot;{0} {1}.{2}不适用\n({3})&quot;}, {&quot;compiler.misc.incompatible.types&quot;, &quot;不兼容的类型&quot;}, {&quot;compiler.misc.incompatible.types.1&quot;, &quot;不兼容的类型; {0}&quot;}, {&quot;compiler.misc.incompatible.upper.bounds&quot;, &quot;推论变量 {0} 具有不兼容的上限 {1}&quot;}, {&quot;compiler.misc.inconvertible.types&quot;, &quot;不可转换的类型&quot;}, {&quot;compiler.misc.infer.arg.length.mismatch&quot;, &quot;无法从参数进行实例化, 因为实际参数列表和形式参数列表长度不同&quot;}, {&quot;compiler.misc.infer.no.conforming.assignment.exists&quot;, &quot;不存在类型变量{0}的实例, 以使参数类型{1}与形式参数类型{2}一致&quot;}, {&quot;compiler.misc.infer.no.conforming.instance.exists&quot;, &quot;不存在类型变量{0}的实例, 以使{1}与{2}一致&quot;}, {&quot;compiler.misc.inferred.do.not.conform.to.bounds&quot;, &quot;推断类型不符合声明的范围\n推断: {0}\n范围: {1}&quot;}, {&quot;compiler.misc.intersection.type&quot;, &quot;INT#{0}&quot;}, {&quot;compiler.misc.kindname.annotation&quot;, &quot;@interface&quot;}, {&quot;compiler.misc.kindname.class&quot;, &quot;类&quot;}, {&quot;compiler.misc.kindname.constructor&quot;, &quot;构造器&quot;}, {&quot;compiler.misc.kindname.enum&quot;, &quot;枚举&quot;}, {&quot;compiler.misc.kindname.instance.init&quot;, &quot;实例初始化程序&quot;}, {&quot;compiler.misc.kindname.interface&quot;, &quot;接口&quot;}, {&quot;compiler.misc.kindname.method&quot;, &quot;方法&quot;}, {&quot;compiler.misc.kindname.package&quot;, &quot;程序包&quot;}, {&quot;compiler.misc.kindname.static&quot;, &quot;静态&quot;}, {&quot;compiler.misc.kindname.static.init&quot;, &quot;静态初始化程序&quot;}, {&quot;compiler.misc.kindname.type.variable&quot;, &quot;类型变量&quot;}, {&quot;compiler.misc.kindname.type.variable.bound&quot;, &quot;类型变量的限制范围&quot;}, {&quot;compiler.misc.kindname.value&quot;, &quot;值&quot;}, {&quot;compiler.misc.kindname.variable&quot;, &quot;变量&quot;}, {&quot;compiler.misc.location&quot;, &quot;{0} {1}&quot;}, {&quot;compiler.misc.location.1&quot;, &quot;类型为{2}的{0} {1}&quot;}, {&quot;compiler.misc.no.args&quot;, &quot;没有参数&quot;}, {&quot;compiler.misc.no.conforming.assignment.exists&quot;, &quot;无法通过方法调用转换将实际参数{0}转换为{1}&quot;}, {&quot;compiler.misc.no.unique.maximal.instance.exists&quot;, &quot;对于上限为{1}的类型变量{0}, 不存在唯一最大实例&quot;}, {&quot;compiler.misc.no.unique.minimal.instance.exists&quot;, &quot;对于下限为{1}的类型变量{0}, 不存在唯一最小实例&quot;}, {&quot;compiler.misc.possible.loss.of.precision&quot;, &quot;可能损失精度&quot;}, {&quot;compiler.misc.resume.abort&quot;, &quot;继续(R), 放弃(A)&gt;&quot;}, {&quot;compiler.misc.source.unavailable&quot;, &quot;(源不可用)&quot;}, {&quot;compiler.misc.token.bad-symbol&quot;, &quot;&lt;错误符号&gt;&quot;}, {&quot;compiler.misc.token.character&quot;, &quot;&lt;字符&gt;&quot;}, {&quot;compiler.misc.token.double&quot;, &quot;&lt;双精度型&gt;&quot;}, {&quot;compiler.misc.token.end-of-input&quot;, &quot;&lt;输入结束&gt;&quot;}, {&quot;compiler.misc.token.float&quot;, &quot;&lt;浮点型&gt;&quot;}, {&quot;compiler.misc.token.identifier&quot;, &quot;&lt;标识符&gt;&quot;}, {&quot;compiler.misc.token.integer&quot;, &quot;&lt;整型&gt;&quot;}, {&quot;compiler.misc.token.long-integer&quot;, &quot;&lt;长整型&gt;&quot;}, {&quot;compiler.misc.token.string&quot;, &quot;&lt;字符串&gt;&quot;}, {&quot;compiler.misc.try.not.applicable.to.type&quot;, &quot;try-with-resources 不适用于变量类型&quot;}, {&quot;compiler.misc.type.captureof&quot;, &quot;capture#{0}, 共 {1}&quot;}, {&quot;compiler.misc.type.captureof.1&quot;, &quot;capture#{0}&quot;}, {&quot;compiler.misc.type.none&quot;, &quot;&lt;无&gt;&quot;}, {&quot;compiler.misc.type.null&quot;, &quot;&lt;空值&gt;&quot;}, {&quot;compiler.misc.type.parameter&quot;, &quot;类型参数{0}&quot;}, {&quot;compiler.misc.type.req.array.or.iterable&quot;, &quot;数组或 java.lang.Iterable&quot;}, {&quot;compiler.misc.type.req.class&quot;, &quot;类&quot;}, {&quot;compiler.misc.type.req.class.array&quot;, &quot;类或数组&quot;}, {&quot;compiler.misc.type.req.exact&quot;, &quot;不带限制范围的类或接口&quot;}, {&quot;compiler.misc.type.req.ref&quot;, &quot;引用&quot;}, {&quot;compiler.misc.type.var&quot;, &quot;{0}#{1}&quot;}, {&quot;compiler.misc.type.variable.has.undetermined.type&quot;, &quot;类型变量{0}带有未确定的类型&quot;}, {&quot;compiler.misc.unable.to.access.file&quot;, &quot;无法访问文件: {0}&quot;}, {&quot;compiler.misc.unchecked.assign&quot;, &quot;未经检查的转换&quot;}, {&quot;compiler.misc.unchecked.cast.to.type&quot;, &quot;未经检查的转换&quot;}, {&quot;compiler.misc.unchecked.clash.with&quot;, &quot;{1}中的{0}覆盖了{3}中的{2}&quot;}, {&quot;compiler.misc.unchecked.implement&quot;, &quot;{1}中的{0}实现了{3}中的{2}&quot;}, {&quot;compiler.misc.unchecked.override&quot;, &quot;{1}中的{0}覆盖了{3}中的{2}&quot;}, {&quot;compiler.misc.undecl.type.var&quot;, &quot;未声明的类型变量: {0}&quot;}, {&quot;compiler.misc.undetermined.type&quot;, &quot;未确定的类型&quot;}, {&quot;compiler.misc.unicode.str.not.supported&quot;, &quot;不支持类文件中的 Unicode 字符串&quot;}, {&quot;compiler.misc.unnamed.package&quot;, &quot;未命名程序包&quot;}, {&quot;compiler.misc.varargs.argument.mismatch&quot;, &quot;参数类型{0}不符合 vararg 元素类型{1}&quot;}, {&quot;compiler.misc.varargs.clash.with&quot;, &quot;{1}中的{0}覆盖了{3}中的{2}&quot;}, {&quot;compiler.misc.varargs.implement&quot;, &quot;{1}中的{0}实现了{3}中的{2}&quot;}, {&quot;compiler.misc.varargs.override&quot;, &quot;{1}中的{0}覆盖了{3}中的{2}&quot;}, {&quot;compiler.misc.varargs.trustme.on.non.varargs.meth&quot;, &quot;方法 {0} 不是 varargs 方法。&quot;}, {&quot;compiler.misc.varargs.trustme.on.reifiable.varargs&quot;, &quot;Varargs 元素类型{0}可具体化。&quot;}, {&quot;compiler.misc.varargs.trustme.on.virtual.varargs&quot;, &quot;实例方法 {0} 不是最终的。&quot;}, {&quot;compiler.misc.verbose.checking.attribution&quot;, &quot;[正在检查{0}]&quot;}, {&quot;compiler.misc.verbose.classpath&quot;, &quot;[类文件的搜索路径: {0}]&quot;}, {&quot;compiler.misc.verbose.loading&quot;, &quot;[正在加载{0}]&quot;}, {&quot;compiler.misc.verbose.parsing.done&quot;, &quot;[解析已完成, 用时 {0} 毫秒]&quot;}, {&quot;compiler.misc.verbose.parsing.started&quot;, &quot;[解析开始时间 {0}]&quot;}, {&quot;compiler.misc.verbose.retro&quot;, &quot;[正在更新{0}]&quot;}, {&quot;compiler.misc.verbose.retro.with&quot;, &quot;\t正在使用{1}更新{0}&quot;}, {&quot;compiler.misc.verbose.retro.with.list&quot;, &quot;\t正在使用类型参数{1}, 超类型{2}和接口{3}更新{0}&quot;}, {&quot;compiler.misc.verbose.sourcepath&quot;, &quot;[源文件的搜索路径: {0}]&quot;}, {&quot;compiler.misc.verbose.total&quot;, &quot;[共 {0} 毫秒]&quot;}, {&quot;compiler.misc.verbose.wrote.file&quot;, &quot;[已写入{0}]&quot;}, {&quot;compiler.misc.version.not.available&quot;, &quot;(版本信息不可用)&quot;}, {&quot;compiler.misc.where.captured&quot;, &quot;{0}从{3}的捕获扩展{1} 超 {2}&quot;}, {&quot;compiler.misc.where.captured.1&quot;, &quot;{0}从{3}的捕获扩展{1}&quot;}, {&quot;compiler.misc.where.description.captured&quot;, &quot;其中, {0}是新类型变量:&quot;}, {&quot;compiler.misc.where.description.captured.1&quot;, &quot;其中, {0}是新类型变量:&quot;}, {&quot;compiler.misc.where.description.intersection&quot;, &quot;其中, {0}是交叉类型:&quot;}, {&quot;compiler.misc.where.description.intersection.1&quot;, &quot;其中, {0}是交叉类型:&quot;}, {&quot;compiler.misc.where.description.typevar&quot;, &quot;其中, {0}是类型变量:&quot;}, {&quot;compiler.misc.where.description.typevar.1&quot;, &quot;其中, {0}是类型变量:&quot;}, {&quot;compiler.misc.where.intersection&quot;, &quot;{0}扩展{1}&quot;}, {&quot;compiler.misc.where.typevar&quot;, &quot;{0}扩展已在{2} {3}中声明的{1}&quot;}, {&quot;compiler.misc.where.typevar.1&quot;, &quot;{0}已在{2} {3}中声明&quot;}, {&quot;compiler.misc.wrong.version&quot;, &quot;类文件具有错误的版本 {0}.{1}, 应为 {2}.{3}&quot;}, {&quot;compiler.misc.x.print.processor.info&quot;, &quot;处理程序{0}与{1}匹配并返回{2}。&quot;}, {&quot;compiler.misc.x.print.rounds&quot;, &quot;循环 {0}:\n\t输入文件: {1}\n\t注释: {2}\n\t最后一个循环: {3}&quot;}, {&quot;compiler.note.deprecated.filename&quot;, &quot;{0}使用或覆盖了已过时的 API。&quot;}, {&quot;compiler.note.deprecated.filename.additional&quot;, &quot;{0}还使用或覆盖了已过时的 API。&quot;}, {&quot;compiler.note.deprecated.plural&quot;, &quot;某些输入文件使用或覆盖了已过时的 API。&quot;}, {&quot;compiler.note.deprecated.plural.additional&quot;, &quot;某些输入文件还使用或覆盖了已过时的 API。&quot;}, {&quot;compiler.note.deprecated.recompile&quot;, &quot;有关详细信息, 请使用 -Xlint:deprecation 重新编译。&quot;}, {&quot;compiler.note.note&quot;, &quot;注: &quot;}, {&quot;compiler.note.proc.messager&quot;, &quot;{0}&quot;}, {&quot;compiler.note.sunapi.filename&quot;, &quot;{0}使用了可能会在未来发行版中删除的内部专用 API。&quot;}, {&quot;compiler.note.sunapi.filename.additional&quot;, &quot;{0}使用了可能会在未来发行版中删除的其他内部专用 API。&quot;}, {&quot;compiler.note.sunapi.plural&quot;, &quot;某些输入文件使用了可能会在未来发行版中删除的内部专用 API。&quot;}, {&quot;compiler.note.sunapi.plural.additional&quot;, &quot;某些输入文件使用了可能会在未来发行版中删除的其他内部专用 API。&quot;}, {&quot;compiler.note.sunapi.recompile&quot;, &quot;有关详细信息, 请使用 -Xlint:sunapi 重新编译。&quot;}, {&quot;compiler.note.unchecked.filename&quot;, &quot;{0}使用了未经检查或不安全的操作。&quot;}, {&quot;compiler.note.unchecked.filename.additional&quot;, &quot;{0}还有未经检查或不安全的操作。&quot;}, {&quot;compiler.note.unchecked.plural&quot;, &quot;某些输入文件使用了未经检查或不安全的操作。&quot;}, {&quot;compiler.note.unchecked.plural.additional&quot;, &quot;某些输入文件还使用了未经检查或不安全的操作。&quot;}, {&quot;compiler.note.unchecked.recompile&quot;, &quot;有关详细信息, 请使用 -Xlint:unchecked 重新编译。&quot;}, {&quot;compiler.warn.annotation.method.not.found&quot;, &quot;无法找到类型 \&#39;\&#39;{0}\&#39;\&#39; 的注释方法 \&#39;\&#39;{1}()\&#39;\&#39;&quot;}, {&quot;compiler.warn.annotation.method.not.found.reason&quot;, &quot;无法找到类型 \&#39;\&#39;{0}\&#39;\&#39; 的注释方法 \&#39;\&#39;{1}()\&#39;\&#39;: {2}&quot;}, {&quot;compiler.warn.assert.as.identifier&quot;, &quot;从发行版 1.4 开始, \&#39;\&#39;assert\&#39;\&#39; 是一个关键字, 但不能用作标识符\n(请使用 -source 1.4 或更高版本以将 \&#39;\&#39;assert\&#39;\&#39; 用作关键字)&quot;}, {&quot;compiler.warn.big.major.version&quot;, &quot;{0}: 主版本 {1} 比 {2} 新, 此编译器支持最新的主版本。\n建议升级此编译器。&quot;}, {&quot;compiler.warn.constant.SVUID&quot;, &quot;serialVersionUID 在类{0}中必须是常量&quot;}, {&quot;compiler.warn.diamond.redundant.args&quot;, &quot;新表达式中存在冗余类型参数 (改用 diamond 运算符)。&quot;}, {&quot;compiler.warn.diamond.redundant.args.1&quot;, &quot;新表达式中存在冗余类型参数 (改用 diamond 运算符)。\n显式: {0}\n推断: {1}&quot;}, {&quot;compiler.warn.dir.path.element.not.found&quot;, &quot;错误的路径元素 \&quot;{0}\&quot;: 没有这种目录&quot;}, {&quot;compiler.warn.div.zero&quot;, &quot;除数为零&quot;}, {&quot;compiler.warn.empty.if&quot;, &quot;if 之后没有语句&quot;}, {&quot;compiler.warn.enum.as.identifier&quot;, &quot;从发行版 5 开始, \&#39;\&#39;enum\&#39;\&#39; 为关键字, 而不用作标识符\n(请使用 -source 5 或更高版本以将 \&#39;\&#39;enum\&#39;\&#39; 用作关键字)&quot;}, {&quot;compiler.warn.finally.cannot.complete&quot;, &quot;finally 子句无法正常完成&quot;}, {&quot;compiler.warn.forward.ref&quot;, &quot;先引用变量 \&#39;\&#39;{0}\&#39;\&#39;, 然后再对其初始化&quot;}, {&quot;compiler.warn.future.attr&quot;, &quot;{1}.{2} 版类文件中引入的 {0} 属性在 {3}.{4} 版类文件中被忽略&quot;}, {&quot;compiler.warn.has.been.deprecated&quot;, &quot;{1}中的{0}已过时&quot;}, {&quot;compiler.warn.illegal.char.for.encoding&quot;, &quot;编码{0}的不可映射字符&quot;}, {&quot;compiler.warn.improper.SVUID&quot;, &quot;必须在类{0}中将 serialVersionUID 声明为 static final&quot;}, {&quot;compiler.warn.inexact.non-varargs.call&quot;, &quot;最后一个参数使用了不准确的变量类型的 varargs 方法的非 varargs 调用; \n对于 varargs 调用, 应使用 {0}\n对于非 varargs 调用, 应使用 {1}, 这样也可以抑制此警告&quot;}, {&quot;compiler.warn.invalid.archive.file&quot;, &quot;以下路径中存在意外的文件: {0}&quot;}, {&quot;compiler.warn.lintOption&quot;, &quot;[{0}] &quot;}, {&quot;compiler.warn.long.SVUID&quot;, &quot;serialVersionUID 在类{0}中必须是 long 类型&quot;}, {&quot;compiler.warn.missing.SVUID&quot;, &quot;可序列化类{0}没有 serialVersionUID 的定义&quot;}, {&quot;compiler.warn.missing.deprecated.annotation&quot;, &quot;未使用 @Deprecated 对已过时的项目进行注释&quot;}, {&quot;compiler.warn.override.bridge&quot;, &quot;{0}; 被覆盖的方法为 bridge 方法&quot;}, {&quot;compiler.warn.override.unchecked.ret&quot;, &quot;{0}\n返回类型需要从{1}到{2}的未经检查的转换&quot;}, {&quot;compiler.warn.override.unchecked.thrown&quot;, &quot;{0}\n被覆盖的方法未抛出{1}&quot;}, {&quot;compiler.warn.override.varargs.extra&quot;, &quot;{0}; 覆盖的方法缺少 \&#39;\&#39;...\&#39;\&#39;&quot;}, {&quot;compiler.warn.override.varargs.missing&quot;, &quot;{0}; 被覆盖的方法没有 \&#39;\&#39;...\&#39;\&#39;&quot;}, {&quot;compiler.warn.path.element.not.found&quot;, &quot;错误的路径元素 \&quot;{0}\&quot;: 没有这种文件或目录&quot;}, {&quot;compiler.warn.pkg-info.already.seen&quot;, &quot;已找到程序包{0}的 package-info.java 文件&quot;}, {&quot;compiler.warn.position.overflow&quot;, &quot;行 {0} 处的位置编码溢出&quot;}, {&quot;compiler.warn.possible.fall-through.into.case&quot;, &quot;可能无法实现 case&quot;}, {&quot;compiler.warn.prob.found.req&quot;, &quot;{0}\n需要: {2}\n找到:    {1}&quot;}, {&quot;compiler.warn.proc.annotations.without.processors&quot;, &quot;没有处理程序要使用以下任何注释: {0}&quot;}, {&quot;compiler.warn.proc.file.create.last.round&quot;, &quot;将不对在最后一个循环中创建的类型为 \&#39;\&#39;{0}\&#39;\&#39; 的文件进行注释处理。&quot;}, {&quot;compiler.warn.proc.file.reopening&quot;, &quot;尝试多次为 \&#39;\&#39;{0}\&#39;\&#39; 创建文件&quot;}, {&quot;compiler.warn.proc.illegal.file.name&quot;, &quot;无法创建带有非法名称 \&#39;\&#39;{0}\&#39;\&#39; 的文件。&quot;}, {&quot;compiler.warn.proc.malformed.supported.string&quot;, &quot;处理程序 \&#39;\&#39;{1}\&#39;\&#39; 为支持的注释类型返回格式错误的字符串 \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;compiler.warn.proc.messager&quot;, &quot;{0}&quot;}, {&quot;compiler.warn.proc.package.does.not.exist&quot;, &quot;程序包{0}不存在&quot;}, {&quot;compiler.warn.proc.proc-only.requested.no.procs&quot;, &quot;在未请求编译的情况下进行注释处理, 但找不到处理程序。&quot;}, {&quot;compiler.warn.proc.processor.incompatible.source.version&quot;, &quot;来自注释处理程序 \&#39;\&#39;{1}\&#39;\&#39; 的受支持 source 版本 \&#39;\&#39;{0}\&#39;\&#39; 低于 -source \&#39;\&#39;{2}\&#39;\&#39;&quot;}, {&quot;compiler.warn.proc.suspicious.class.name&quot;, &quot;正在为名称以{1}结尾的类型创建文件: \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;compiler.warn.proc.type.already.exists&quot;, &quot;类型 \&#39;\&#39;{0}\&#39;\&#39; 的文件已经存在于源路径或类路径中&quot;}, {&quot;compiler.warn.proc.type.recreate&quot;, &quot;尝试多次创建类型 \&#39;\&#39;{0}\&#39;\&#39; 的文件&quot;}, {&quot;compiler.warn.proc.unclosed.type.files&quot;, &quot;类型 \&#39;\&#39;{0}\&#39;\&#39; 的文件未关闭; 将不针对这些类型进行注释处理&quot;}, {&quot;compiler.warn.proc.unmatched.processor.options&quot;, &quot;以下选项未被任何处理程序识别: \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;compiler.warn.proc.use.implicit&quot;, &quot;注释处理不适用于隐式编译的文件。\n使用 -implicit 指定用于隐式编译的策略。&quot;}, {&quot;compiler.warn.proc.use.proc.or.implicit&quot;, &quot;注释处理不适用于隐式编译的文件。\n使用 -proc:none 禁用注释处理或使用 -implicit 指定用于隐式编译的策略。&quot;}, {&quot;compiler.warn.raw.class.use&quot;, &quot;找到原始类型: {0}\n缺少泛型类{1}的类型参数&quot;}, {&quot;compiler.warn.redundant.cast&quot;, &quot;出现冗余的到{0}的转换&quot;}, {&quot;compiler.warn.self.ref&quot;, &quot;变量 \&#39;\&#39;{0}\&#39;\&#39; 的初始化程序中存在自引用&quot;}, {&quot;compiler.warn.source.no.bootclasspath&quot;, &quot;未与 -source {0} 一起设置引导类路径&quot;}, {&quot;compiler.warn.static.not.qualified.by.type&quot;, &quot;static {0}应由类型名称{1}而不是表达式限定&quot;}, {&quot;compiler.warn.sun.proprietary&quot;, &quot;{0}是内部专用 API, 可能会在未来发行版中删除&quot;}, {&quot;compiler.warn.synthetic.name.conflict&quot;, &quot;符号{0}与{1}中的 compiler-synthesized 符号冲突&quot;}, {&quot;compiler.warn.try.explicit.close.call&quot;, &quot;在可自动结束的资源上显式调用 close()&quot;}, {&quot;compiler.warn.try.resource.not.referenced&quot;, &quot;不能在相应的 try 语句的正文中引用可自动结束的资源{0}&quot;}, {&quot;compiler.warn.try.resource.throws.interrupted.exc&quot;, &quot;可自动关闭的资源{0}包含的成员方法 close() 可能抛出 InterruptedException&quot;}, {&quot;compiler.warn.unchecked.assign&quot;, &quot;未经检查的分配: 将{0}分配给{1}&quot;}, {&quot;compiler.warn.unchecked.assign.to.var&quot;, &quot;对作为原始类型{1}的成员的变量{0}的分配未经过检查&quot;}, {&quot;compiler.warn.unchecked.call.mbr.of.raw.type&quot;, &quot;对作为原始类型{1}的成员的{0}的调用未经过检查&quot;}, {&quot;compiler.warn.unchecked.cast.to.type&quot;, &quot;向类型{0}的转换未经过检查&quot;}, {&quot;compiler.warn.unchecked.generic.array.creation&quot;, &quot;对于类型为{0}的 varargs 参数, 泛型数组创建未经过检查&quot;}, {&quot;compiler.warn.unchecked.meth.invocation.applied&quot;, &quot;方法调用未经过检查: 将{4} {5}中的{0} {1}应用到给定的类型\n需要: {2}\n找到: {3}&quot;}, {&quot;compiler.warn.unchecked.varargs.non.reifiable.type&quot;, &quot;参数化 vararg 类型{0}的堆可能已受污染&quot;}, {&quot;compiler.warn.unexpected.archive.file&quot;, &quot;以下档案文件存在意外的扩展名: {0}&quot;}, {&quot;compiler.warn.unknown.enum.constant&quot;, &quot;未知的枚举常量 {1}.{2}&quot;}, {&quot;compiler.warn.unknown.enum.constant.reason&quot;, &quot;未知的枚举常量 {1}.{2}\n原因: {3}&quot;}, {&quot;compiler.warn.unreachable.catch&quot;, &quot;catch 子句无法访问\n已捕获到抛出的类型{0}&quot;}, {&quot;compiler.warn.unreachable.catch.1&quot;, &quot;catch 子句无法访问\n已捕获到抛出的类型{0}&quot;}, {&quot;compiler.warn.varargs.redundant.trustme.anno&quot;, &quot;冗余的 {0} 注释。{1}&quot;}, {&quot;compiler.warn.varargs.unsafe.use.varargs.param&quot;, &quot;Varargs 方法可能导致来自不可具体化 varargs 参数 {0} 的堆污染&quot;}, {&quot;compiler.warn.warning&quot;, &quot;警告: &quot;}};
<i>16</i>&nbsp;    }
<i>17</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2014-12-21 15:54</div>
</div>
</body>
</html>
