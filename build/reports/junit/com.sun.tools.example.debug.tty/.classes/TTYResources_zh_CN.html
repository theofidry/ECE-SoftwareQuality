


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: TTYResources_zh_CN</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.tools.example.debug.tty</a> ]
</div>

<h1>Coverage Summary for Class: TTYResources_zh_CN (com.sun.tools.example.debug.tty)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TTYResources_zh_CN</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;//
<i>2</i>&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
<i>3</i>&nbsp;// (powered by Fernflower decompiler)
<i>4</i>&nbsp;//
<i>5</i>&nbsp;
<i>6</i>&nbsp;package com.sun.tools.example.debug.tty;
<i>7</i>&nbsp;
<i>8</i>&nbsp;import java.util.ListResourceBundle;
<i>9</i>&nbsp;
<i>10</i>&nbsp;public class TTYResources_zh_CN extends ListResourceBundle {
<i>11</i>&nbsp;    public TTYResources_zh_CN() {
<i>12</i>&nbsp;    }
<i>13</i>&nbsp;
<i>14</i>&nbsp;    public Object[][] getContents() {
<i>15</i>&nbsp;        Object[][] var1 = new Object[][]{{&quot;** classes list **&quot;, &quot;** 类列表 **\n{0}&quot;}, {&quot;** fields list **&quot;, &quot;** 字段列表 **\n{0}&quot;}, {&quot;** methods list **&quot;, &quot;** 方法列表 **\n{0}&quot;}, {&quot;*** Reading commands from&quot;, &quot;*** 正在从{0}读取命令&quot;}, {&quot;All threads resumed.&quot;, &quot;已恢复所有线程。&quot;}, {&quot;All threads suspended.&quot;, &quot;已挂起所有线程。&quot;}, {&quot;Argument is not defined for connector:&quot;, &quot;没有为连接器{1}定义参数{0}&quot;}, {&quot;Arguments match no method&quot;, &quot;参数不与任何方法匹配&quot;}, {&quot;Array:&quot;, &quot;数组: {0}&quot;}, {&quot;Array element is not a method&quot;, &quot;数组元素不是方法&quot;}, {&quot;Array index must be a integer type&quot;, &quot;数组索引必须为整数类型&quot;}, {&quot;base directory:&quot;, &quot;基目录: {0}&quot;}, {&quot;bootclasspath:&quot;, &quot;引导类路径: {0}&quot;}, {&quot;Breakpoint hit:&quot;, &quot;断点命中: &quot;}, {&quot;breakpoint&quot;, &quot;断点{0}&quot;}, {&quot;Breakpoints set:&quot;, &quot;断点集:&quot;}, {&quot;Breakpoints can be located only in classes.&quot;, &quot;断点只能位于类中。{0}是接口或数组。&quot;}, {&quot;Can only trace&quot;, &quot;只能跟踪 \&#39;methods\&#39;, \&#39;method exit\&#39; 或 \&#39;method exits\&#39;&quot;}, {&quot;cannot redefine existing connection&quot;, &quot;{0}无法重新定义现有连接&quot;}, {&quot;Cannot assign to a method invocation&quot;, &quot;无法分配到方法调用&quot;}, {&quot;Cannot specify command line with connector:&quot;, &quot;无法指定带有连接器的命令行: {0}&quot;}, {&quot;Cannot specify target vm arguments with connector:&quot;, &quot;无法指定带有连接器的目标 VM 参数: {0}&quot;}, {&quot;Class containing field must be specified.&quot;, &quot;必须指定包含字段的类。&quot;}, {&quot;Class:&quot;, &quot;类: {0}&quot;}, {&quot;Classic VM no longer supported.&quot;, &quot;不再支持经典 VM。&quot;}, {&quot;classpath:&quot;, &quot;类路径: {0}&quot;}, {&quot;colon mark&quot;, &quot;:&quot;}, {&quot;colon space&quot;, &quot;: &quot;}, {&quot;Command is not supported on the target VM&quot;, &quot;目标 VM 不支持命令 \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;Command is not supported on a read-only VM connection&quot;, &quot;只读 VM 连接不支持命令 \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;Command not valid until the VM is started with the run command&quot;, &quot;在使用 \&#39;\&#39;run\&#39;\&#39; 命令启动 VM 前, 命令 \&#39;\&#39;{0}\&#39;\&#39; 是无效的&quot;}, {&quot;Condition must be boolean&quot;, &quot;条件必须是布尔型&quot;}, {&quot;Connector and Transport name&quot;, &quot;  连接器: {0}, 传输: {1}&quot;}, {&quot;Connector argument nodefault&quot;, &quot;    参数: {0} (无默认值)&quot;}, {&quot;Connector argument default&quot;, &quot;    参数: {0}, 默认值: {1}&quot;}, {&quot;Connector description&quot;, &quot;    说明: {0}&quot;}, {&quot;Connector required argument nodefault&quot;, &quot;    所需的参数: {0} (无默认值)&quot;}, {&quot;Connector required argument default&quot;, &quot;    所需的参数: {0}, 默认值: {1}&quot;}, {&quot;Connectors available&quot;, &quot;可用连接器为:&quot;}, {&quot;Constant is not a method&quot;, &quot;常量不是方法&quot;}, {&quot;Could not open:&quot;, &quot;无法打开: {0}&quot;}, {&quot;Current method is native&quot;, &quot;当前方法为本机方法&quot;}, {&quot;Current thread died. Execution continuing...&quot;, &quot;当前线程{0}已成为死线程。继续执行...&quot;}, {&quot;Current thread isnt suspended.&quot;, &quot;当前线程未挂起。&quot;}, {&quot;Current thread not set.&quot;, &quot;当前线程未设置。&quot;}, {&quot;dbgtrace flag value must be an integer:&quot;, &quot;dbgtrace 标记值必须为整数: {0}&quot;}, {&quot;Deferring.&quot;, &quot;正在延迟{0}。\n将在加载类后设置。&quot;}, {&quot;End of stack.&quot;, &quot;堆栈结束。&quot;}, {&quot;Error popping frame&quot;, &quot;使帧出栈时出错 - {0}&quot;}, {&quot;Error reading file&quot;, &quot;读取 \&#39;\&#39;{0}\&#39;\&#39; 时出错 - {1}&quot;}, {&quot;Error redefining class to file&quot;, &quot;将{0}重新定义为{1}时出错 - {2}&quot;}, {&quot;exceptionSpec all&quot;, &quot;所有{0}&quot;}, {&quot;exceptionSpec caught&quot;, &quot;捕获的{0}&quot;}, {&quot;exceptionSpec uncaught&quot;, &quot;未捕获的{0}&quot;}, {&quot;Exception in expression:&quot;, &quot;表达式中出现异常错误: {0}&quot;}, {&quot;Exception occurred caught&quot;, &quot;出现异常错误: {0} (将在以下位置捕获: {1})&quot;}, {&quot;Exception occurred uncaught&quot;, &quot;出现异常错误: {0} (未捕获)&quot;}, {&quot;Exceptions caught:&quot;, &quot;出现这些异常错误时中断:&quot;}, {&quot;expr is null&quot;, &quot;{0} = 空值&quot;}, {&quot;expr is value&quot;, &quot;{0} = {1}&quot;}, {&quot;expr is value &lt;collected&gt;&quot;, &quot;  {0} = {1} &lt;已收集&gt;&quot;}, {&quot;Expression cannot be void&quot;, &quot;表达式不能为空&quot;}, {&quot;Expression must evaluate to an object&quot;, &quot;表达式的计算结果必须为对象&quot;}, {&quot;extends:&quot;, &quot;扩展: {0}&quot;}, {&quot;Failed reading output&quot;, &quot;无法读取子 Java 解释器的输出。&quot;}, {&quot;Fatal error&quot;, &quot;致命错误:&quot;}, {&quot;Field access encountered before after&quot;, &quot;字段 ({0}) 为{1}, 将为{2}: &quot;}, {&quot;Field access encountered&quot;, &quot;遇到字段 ({0}) 访问: &quot;}, {&quot;Field to unwatch not specified&quot;, &quot;未指定要取消监视的字段。&quot;}, {&quot;Field to watch not specified&quot;, &quot;未指定要监视的字段。&quot;}, {&quot;GC Disabled for&quot;, &quot;已对{0}禁用 GC:&quot;}, {&quot;GC Enabled for&quot;, &quot;已对{0}启用 GC:&quot;}, {&quot;grouping begin character&quot;, &quot;{&quot;}, {&quot;grouping end character&quot;, &quot;}&quot;}, {&quot;Illegal Argument Exception&quot;, &quot;非法参数异常错误&quot;}, {&quot;Illegal connector argument&quot;, &quot;非法连接器参数: {0}&quot;}, {&quot;implementor:&quot;, &quot;实现者: {0}&quot;}, {&quot;implements:&quot;, &quot;实现: {0}&quot;}, {&quot;Initializing progname&quot;, &quot;正在初始化{0}...&quot;}, {&quot;Input stream closed.&quot;, &quot;输入流已关闭。&quot;}, {&quot;Interface:&quot;, &quot;接口: {0}&quot;}, {&quot;Internal debugger error.&quot;, &quot;内部调试器错误。&quot;}, {&quot;Internal error: null ThreadInfo created&quot;, &quot;内部错误: 创建了空值 ThreadInfo&quot;}, {&quot;Internal error; unable to set&quot;, &quot;内部错误; 无法设置{0}&quot;}, {&quot;Internal exception during operation:&quot;, &quot;操作期间出现内部异常错误:\n    {0}&quot;}, {&quot;Internal exception:&quot;, &quot;内部异常错误:&quot;}, {&quot;Invalid argument type name&quot;, &quot;参数类型名称无效&quot;}, {&quot;Invalid assignment syntax&quot;, &quot;赋值语法无效&quot;}, {&quot;Invalid command syntax&quot;, &quot;命令语法无效&quot;}, {&quot;Invalid connect type&quot;, &quot;连接类型无效&quot;}, {&quot;Invalid consecutive invocations&quot;, &quot;连续调用无效&quot;}, {&quot;Invalid exception object&quot;, &quot;异常错误对象无效&quot;}, {&quot;Invalid method specification:&quot;, &quot;方法规范无效: {0}&quot;}, {&quot;Invalid option on class command&quot;, &quot;类命令的选项无效&quot;}, {&quot;invalid option&quot;, &quot;选项无效: {0}&quot;}, {&quot;Invalid thread status.&quot;, &quot;线程状态无效。&quot;}, {&quot;Invalid transport name:&quot;, &quot;传输名称无效: {0}&quot;}, {&quot;I/O exception occurred:&quot;, &quot;出现 I/O 异常错误: {0}&quot;}, {&quot;is an ambiguous method name in&quot;, &quot;\&quot;{0}\&quot; 在 \&quot;{1}\&quot; 中是不明确的方法名称&quot;}, {&quot;is an invalid line number for&quot;, &quot;{0,number,integer} 是{1}的无效行号&quot;}, {&quot;is not a valid class name&quot;, &quot;\&quot;{0}\&quot; 不是有效的类名。&quot;}, {&quot;is not a valid field name&quot;, &quot;\&quot;{0}\&quot; 不是有效的字段名。&quot;}, {&quot;is not a valid id or class name&quot;, &quot;\&quot;{0}\&quot; 不是有效的 ID 或类名。&quot;}, {&quot;is not a valid line number or method name for&quot;, &quot;\&quot;{0}\&quot; 不是类 \&quot;{1}\&quot; 的有效行号或方法名&quot;}, {&quot;is not a valid method name&quot;, &quot;\&quot;{0}\&quot; 不是有效的方法名。&quot;}, {&quot;is not a valid thread id&quot;, &quot;\&quot;{0}\&quot; 不是有效的线程 ID。&quot;}, {&quot;is not a valid threadgroup name&quot;, &quot;\&quot;{0}\&quot; 不是有效的线程组名称。&quot;}, {&quot;jdb prompt with no current thread&quot;, &quot;&gt; &quot;}, {&quot;jdb prompt thread name and current stack frame&quot;, &quot;{0}[{1,number,integer}] &quot;}, {&quot;killed&quot;, &quot;{0}已终止&quot;}, {&quot;killing thread:&quot;, &quot;正在终止线程: {0}&quot;}, {&quot;Line number information not available for&quot;, &quot;此位置的源行号不可用。&quot;}, {&quot;line number&quot;, &quot;:{0,number,integer}&quot;}, {&quot;list field typename and name&quot;, &quot;{0} {1}\n&quot;}, {&quot;list field typename and name inherited&quot;, &quot;{0} {1} (继承自{2})\n&quot;}, {&quot;list field typename and name hidden&quot;, &quot;{0} {1} (隐藏)\n&quot;}, {&quot;Listening at address:&quot;, &quot;监听地址: {0}&quot;}, {&quot;Local variable information not available.&quot;, &quot;本地变量信息不可用。请使用 -g 编译以生成变量信息&quot;}, {&quot;Local variables:&quot;, &quot;本地变量:&quot;}, {&quot;&lt;location unavailable&gt;&quot;, &quot;&lt;位置不可用&gt;&quot;}, {&quot;location&quot;, &quot;\&quot;线程={0}\&quot;, {1}&quot;}, {&quot;locationString&quot;, &quot;{0}.{1}(), 行={2,number,integer} bci={3,number,integer}&quot;}, {&quot;Main class and arguments must be specified&quot;, &quot;必须指定主类和参数&quot;}, {&quot;Method arguments:&quot;, &quot;方法参数:&quot;}, {&quot;Method entered:&quot;, &quot;已进入方法: &quot;}, {&quot;Method exited:&quot;, &quot;已退出方法&quot;}, {&quot;Method exitedValue:&quot;, &quot;已退出方法: 返回值 = {0}, &quot;}, {&quot;Method is overloaded; specify arguments&quot;, &quot;已重载方法{0}; 请指定参数&quot;}, {&quot;minus version&quot;, &quot;这是{0}版本 {1,number,integer}.{2,number,integer} (Java SE 版本 {3})&quot;}, {&quot;Monitor information for thread&quot;, &quot;监视线程{0}的信息:&quot;}, {&quot;Monitor information for expr&quot;, &quot;监视{0} ({1}) 的信息:&quot;}, {&quot;More than one class named&quot;, &quot;多个类的名称为: \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;native method&quot;, &quot;本机方法&quot;}, {&quot;nested:&quot;, &quot;嵌套: {0}&quot;}, {&quot;No attach address specified.&quot;, &quot;未指定附加地址。&quot;}, {&quot;No breakpoints set.&quot;, &quot;未设置断点。&quot;}, {&quot;No class named&quot;, &quot;没有名为 \&#39;\&#39;{0}\&#39;\&#39; 的类&quot;}, {&quot;No class specified.&quot;, &quot;未指定类。&quot;}, {&quot;No classpath specified.&quot;, &quot;未指定类路径。&quot;}, {&quot;No code at line&quot;, &quot;{1}中的行 {0,number,integer} 处没有代码&quot;}, {&quot;No connect specification.&quot;, &quot;没有连接规范。&quot;}, {&quot;No connector named:&quot;, &quot;没有名为{0}的连接器&quot;}, {&quot;No current thread&quot;, &quot;没有当前线程&quot;}, {&quot;No default thread specified:&quot;, &quot;未指定默认线程: 请先使用 \&quot;thread\&quot; 命令。&quot;}, {&quot;No exception object specified.&quot;, &quot;未指定异常错误对象。&quot;}, {&quot;No exceptions caught.&quot;, &quot;未捕获到异常错误。&quot;}, {&quot;No expression specified.&quot;, &quot;未指定表达式。&quot;}, {&quot;No field in&quot;, &quot;{1}中没有字段{0}&quot;}, {&quot;No frames on the current call stack&quot;, &quot;当前调用堆栈上没有帧&quot;}, {&quot;No linenumber information for&quot;, &quot;{0}没有行号信息。请尝试在启用调试的情况下编译。&quot;}, {&quot;No local variables&quot;, &quot;没有本地变量&quot;}, {&quot;No method in&quot;, &quot;{1}中没有方法{0}&quot;}, {&quot;No method specified.&quot;, &quot;未指定方法。&quot;}, {&quot;No monitor numbered:&quot;, &quot;没有编号为 {0} 的监视器&quot;}, {&quot;No monitors owned&quot;, &quot;  不拥有监视器&quot;}, {&quot;No object specified.&quot;, &quot;未指定对象。&quot;}, {&quot;No objects specified.&quot;, &quot;未指定对象。&quot;}, {&quot;No save index specified.&quot;, &quot;未指定保存索引。&quot;}, {&quot;No saved values&quot;, &quot;没有保存的值&quot;}, {&quot;No source information available for:&quot;, &quot;没有可用于{0}的源信息&quot;}, {&quot;No sourcedebugextension specified&quot;, &quot;未指定 SourceDebugExtension&quot;}, {&quot;No sourcepath specified.&quot;, &quot;未指定源路径。&quot;}, {&quot;No thread specified.&quot;, &quot;未指定线程。&quot;}, {&quot;No VM connected&quot;, &quot;未连接 VM&quot;}, {&quot;No waiters&quot;, &quot;  没有等待进程&quot;}, {&quot;not a class&quot;, &quot;{0}不是类&quot;}, {&quot;Not a monitor number:&quot;, &quot;不是监视器编号: \&#39;\&#39;{0}\&#39;\&#39;&quot;}, {&quot;not found (try the full name)&quot;, &quot;找不到{0} (请尝试使用全名)&quot;}, {&quot;Not found:&quot;, &quot;找不到: {0}&quot;}, {&quot;not found&quot;, &quot;找不到{0}&quot;}, {&quot;Not owned&quot;, &quot;  不拥有&quot;}, {&quot;Not waiting for a monitor&quot;, &quot;  未等待监视器&quot;}, {&quot;Nothing suspended.&quot;, &quot;未挂起任何对象。&quot;}, {&quot;object description and hex id&quot;, &quot;({0}){1}&quot;}, {&quot;Operation is not supported on the target VM&quot;, &quot;目标 VM 不支持该操作&quot;}, {&quot;operation not yet supported&quot;, &quot;尚不支持该操作&quot;}, {&quot;Owned by:&quot;, &quot;  拥有者: {0}, 条目计数: {1,number,integer}&quot;}, {&quot;Owned monitor:&quot;, &quot;  拥有的监视器: {0}&quot;}, {&quot;Parse exception:&quot;, &quot;解析异常错误: {0}&quot;}, {&quot;printbreakpointcommandusage&quot;, &quot;用法: {0} &lt;class&gt;:&lt;line_number&gt; 或\n       {1} &lt;class&gt;.&lt;method_name&gt;[(argument_type,...)]&quot;}, {&quot;Removed:&quot;, &quot;已删除: {0}&quot;}, {&quot;Requested stack frame is no longer active:&quot;, &quot;请求的堆栈帧不再有效: {0,number,integer}&quot;}, {&quot;run &lt;args&gt; command is valid only with launched VMs&quot;, &quot;\&#39;run &lt;args&gt;\&#39; 命令仅对启动的 VM 有效&quot;}, {&quot;run&quot;, &quot;运行{0}&quot;}, {&quot;saved&quot;, &quot;{0}已保存&quot;}, {&quot;Set deferred&quot;, &quot;设置延迟的{0}&quot;}, {&quot;Set&quot;, &quot;设置{0}&quot;}, {&quot;Source file not found:&quot;, &quot;找不到源文件: {0}&quot;}, {&quot;source line number and line&quot;, &quot;{0,number,integer}    {1}&quot;}, {&quot;source line number current line and line&quot;, &quot;{0,number,integer} =&gt; {1}&quot;}, {&quot;sourcedebugextension&quot;, &quot;SourceDebugExtension -- {0}&quot;}, {&quot;Specify class and method&quot;, &quot;指定类和方法&quot;}, {&quot;Specify classes to redefine&quot;, &quot;指定要重新定义的类&quot;}, {&quot;Specify file name for class&quot;, &quot;指定类{0}的文件名&quot;}, {&quot;stack frame dump with pc&quot;, &quot;  [{0,number,integer}] {1}.{2} ({3}), pc = {4}&quot;}, {&quot;stack frame dump&quot;, &quot;  [{0,number,integer}] {1}.{2} ({3})&quot;}, {&quot;Step completed:&quot;, &quot;已完成的步骤: &quot;}, {&quot;Stopping due to deferred breakpoint errors.&quot;, &quot;由于延迟断点错误而停止。\n&quot;}, {&quot;subclass:&quot;, &quot;子类: {0}&quot;}, {&quot;subinterface:&quot;, &quot;子接口: {0}&quot;}, {&quot;tab&quot;, &quot;\t{0}&quot;}, {&quot;Target VM failed to initialize.&quot;, &quot;无法初始化目标 VM。&quot;}, {&quot;The application exited&quot;, &quot;应用程序已退出&quot;}, {&quot;The application has been disconnected&quot;, &quot;应用程序已断开连接&quot;}, {&quot;The gc command is no longer necessary.&quot;, &quot;不再需要 \&#39;gc\&#39; 命令。\n所有对象已照常进行垃圾收集。请使用 \&#39;enablegc\&#39; 和 \&#39;disablegc\&#39;\n命令来控制各个对象的垃圾收集。&quot;}, {&quot;The load command is no longer supported.&quot;, &quot;不再支持 \&#39;load\&#39; 命令。&quot;}, {&quot;The memory command is no longer supported.&quot;, &quot;不再支持 \&#39;memory\&#39; 命令。&quot;}, {&quot;The VM does not use paths&quot;, &quot;VM 不使用路径&quot;}, {&quot;Thread is not running (no stack).&quot;, &quot;线程未运行 (没有堆栈)。&quot;}, {&quot;Thread number not specified.&quot;, &quot;未指定线程编号。&quot;}, {&quot;Thread:&quot;, &quot;{0}:&quot;}, {&quot;Thread Group:&quot;, &quot;组{0}:&quot;}, {&quot;Thread description name unknownStatus BP&quot;, &quot;  {0} {1}未知 (在断点处)&quot;}, {&quot;Thread description name unknownStatus&quot;, &quot;  {0} {1}未知&quot;}, {&quot;Thread description name zombieStatus BP&quot;, &quot;  {0} {1}处于僵死状态 (在断点处)&quot;}, {&quot;Thread description name zombieStatus&quot;, &quot;  {0} {1}处于僵死状态&quot;}, {&quot;Thread description name runningStatus BP&quot;, &quot;  {0} {1}正在运行 (在断点处)&quot;}, {&quot;Thread description name runningStatus&quot;, &quot;  {0} {1}正在运行&quot;}, {&quot;Thread description name sleepingStatus BP&quot;, &quot;  {0} {1}正在休眠 (在断点处)&quot;}, {&quot;Thread description name sleepingStatus&quot;, &quot;  {0} {1}正在休眠&quot;}, {&quot;Thread description name waitingStatus BP&quot;, &quot;  {0} {1}正在等待监视器 (在断点处)&quot;}, {&quot;Thread description name waitingStatus&quot;, &quot;  {0} {1}正在等待监视器&quot;}, {&quot;Thread description name condWaitstatus BP&quot;, &quot;  {0} {1}正在执行条件等待 (在断点处)&quot;}, {&quot;Thread description name condWaitstatus&quot;, &quot;  {0} {1}正在执行条件等待&quot;}, {&quot;Thread has been resumed&quot;, &quot;已恢复线程&quot;}, {&quot;Thread not suspended&quot;, &quot;未挂起线程&quot;}, {&quot;thread group number description name&quot;, &quot;{0,number,integer}。{1} {2}&quot;}, {&quot;Threadgroup name not specified.&quot;, &quot;未指定线程组名。&quot;}, {&quot;Threads must be suspended&quot;, &quot;必须挂起线程&quot;}, {&quot;trace method exit in effect for&quot;, &quot;正在对{0}实行 trace method exit&quot;}, {&quot;trace method exits in effect&quot;, &quot;正在实行 trace method exits&quot;}, {&quot;trace methods in effect&quot;, &quot;正在实行 trace methods&quot;}, {&quot;trace go method exit in effect for&quot;, &quot;正在对{0}实行 trace go method exit&quot;}, {&quot;trace go method exits in effect&quot;, &quot;正在实行 trace go method exits&quot;}, {&quot;trace go methods in effect&quot;, &quot;正在实行 trace go methods&quot;}, {&quot;trace not in effect&quot;, &quot;未实行 trace&quot;}, {&quot;Unable to attach to target VM.&quot;, &quot;无法附加到目标 VM。&quot;}, {&quot;Unable to display process output:&quot;, &quot;无法显示进程输出: {0}&quot;}, {&quot;Unable to launch target VM.&quot;, &quot;无法启动目标 VM。&quot;}, {&quot;Unable to set deferred&quot;, &quot;无法设置延迟的{0}: {1}&quot;}, {&quot;Unable to set main class and arguments&quot;, &quot;无法设置主类和参数&quot;}, {&quot;Unable to set&quot;, &quot;无法设置{0}: {1}&quot;}, {&quot;Unexpected event type&quot;, &quot;意外的事件类型: {0}&quot;}, {&quot;unknown&quot;, &quot;未知&quot;}, {&quot;Unmonitoring&quot;, &quot;取消监视{0} &quot;}, {&quot;Unrecognized command.  Try help...&quot;, &quot;无法识别的命令: \&#39;\&#39;{0}\&#39;\&#39;。请尝试获得帮助...&quot;}, {&quot;Usage: catch exception&quot;, &quot;用法: catch [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;&quot;}, {&quot;Usage: ignore exception&quot;, &quot;用法: ignore [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;&quot;}, {&quot;Usage: down [n frames]&quot;, &quot;用法: down [n frames]&quot;}, {&quot;Usage: kill &lt;thread id&gt; &lt;throwable&gt;&quot;, &quot;用法: kill &lt;thread id&gt; &lt;throwable&gt;&quot;}, {&quot;Usage: read &lt;command-filename&gt;&quot;, &quot;用法: read &lt;command-filename&gt;&quot;}, {&quot;Usage: unmonitor &lt;monitor#&gt;&quot;, &quot;用法: unmonitor &lt;monitor#&gt;&quot;}, {&quot;Usage: up [n frames]&quot;, &quot;用法: up [n frames]&quot;}, {&quot;Use java minus X to see&quot;, &quot;使用 \&#39;java -X\&#39; 可以查看可用的非标准选项&quot;}, {&quot;Use stop at to set a breakpoint at a line number&quot;, &quot;使用 \&#39;stop at\&#39; 可以在行号处设置断点&quot;}, {&quot;VM already running. use cont to continue after events.&quot;, &quot;VM 已在运行。请使用 \&#39;cont\&#39; 以在事件结束后继续。&quot;}, {&quot;VM Started:&quot;, &quot;VM 已启动: &quot;}, {&quot;vmstartexception&quot;, &quot;VM 启动异常错误: {0}&quot;}, {&quot;Waiting for monitor:&quot;, &quot;   正在等待监视器: {0}&quot;}, {&quot;Waiting thread:&quot;, &quot; 正在等待线程: {0}&quot;}, {&quot;watch accesses of&quot;, &quot;监视{0}.{1}的访问&quot;}, {&quot;watch modification of&quot;, &quot;监视{0}.{1}的修改&quot;}, {&quot;zz help text&quot;, &quot;** 命令列表 **\nconnectors                -- 列出此 VM 中可用的连接器和传输\n\nrun [class [args]]        -- 开始执行应用程序的主类\n\nthreads [threadgroup]     -- 列出线程\nthread &lt;thread id&gt;        -- 设置默认线程\nsuspend [thread id(s)]    -- 挂起线程 (默认值: all)\nresume [thread id(s)]     -- 恢复线程 (默认值: all)\nwhere [&lt;thread id&gt; | all] -- 转储线程的堆栈\nwherei [&lt;thread id&gt; | all]-- 转储线程的堆栈, 以及 pc 信息\nup [n frames]             -- 上移线程的堆栈\ndown [n frames]           -- 下移线程的堆栈\nkill &lt;thread id&gt; &lt;expr&gt;   -- 终止具有给定的异常错误对象的线程\ninterrupt &lt;thread id&gt;     -- 中断线程\n\nprint &lt;expr&gt;              -- 输出表达式的值\ndump &lt;expr&gt;               -- 输出所有对象信息\neval &lt;expr&gt;               -- 对表达式求值 (与 print 相同)\nset &lt;lvalue&gt; = &lt;expr&gt;     -- 向字段/变量/数组元素分配新值\nlocals                    -- 输出当前堆栈帧中的所有本地变量\n\nclasses                   -- 列出当前已知的类\nclass &lt;class id&gt;          -- 显示已命名类的详细资料\nmethods &lt;class id&gt;        -- 列出类的方法\nfields &lt;class id&gt;         -- 列出类的字段\n\nthreadgroups              -- 列出线程组\nthreadgroup &lt;name&gt;        -- 设置当前线程组\n\nstop in &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]\n                          -- 在方法中设置断点\nstop at &lt;class id&gt;:&lt;line&gt; -- 在行中设置断点\nclear &lt;class id&gt;.&lt;method&gt;[(argument_type,...)]\n                          -- 清除方法中的断点\nclear &lt;class id&gt;:&lt;line&gt;   -- 清除行中的断点\nclear                     -- 列出断点\ncatch [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;\n                          -- 出现指定的异常错误时中断\nignore [uncaught|caught|all] &lt;class id&gt;|&lt;class pattern&gt;\n                          -- 对于指定的异常错误, 取消 \&#39;catch\&#39;\nwatch [access|all] &lt;class id&gt;.&lt;field name&gt;\n                          -- 监视对字段的访问/修改\nunwatch [access|all] &lt;class id&gt;.&lt;field name&gt;\n                          -- 停止监视对字段的访问/修改\ntrace [go] methods [thread]\n                          -- 跟踪方法进入和退出。\n                          -- 除非指定 \&#39;go\&#39;, 否则挂起所有线程\ntrace [go] method exit | exits [thread]\n                          -- 跟踪当前方法的退出, 或者所有方法的退出\n                          -- 除非指定 \&#39;go\&#39;, 否则挂起所有线程\nuntrace [methods]         -- 停止跟踪方法进入和/或退出\nstep                      -- 执行当前行\nstep up                   -- 一直执行, 直到当前方法返回到其调用方\nstepi                     -- 执行当前指令\n下一步                      -- 步进一行 (步过调用)\ncont                      -- 从断点处继续执行\n\nlist [line number|method] -- 输出源代码\nuse (或 sourcepath) [source file path]\n                          -- 显示或更改源路径\nexclude [&lt;class pattern&gt;, ... | \&quot;none\&quot;]\n                          -- 对于指定的类, 不报告步骤或方法事件\nclasspath                 -- 从目标 VM 输出类路径信息\n\nmonitor &lt;command&gt;         -- 每次程序停止时执行命令\nmonitor                   -- 列出监视器\nunmonitor &lt;monitor#&gt;      -- 删除监视器\nread &lt;filename&gt;           -- 读取并执行命令文件\n\nlock &lt;expr&gt;               -- 输出对象的锁信息\nthreadlocks [thread id]   -- 输出线程的锁信息\n\npop                       -- 通过当前帧出栈, 且包含当前帧\nreenter                   -- 与 pop 相同, 但重新进入当前帧\nredefine &lt;class id&gt; &lt;class file name&gt;\n                          -- 重新定义类的代码\n\ndisablegc &lt;expr&gt;          -- 禁止对象的垃圾收集\nenablegc &lt;expr&gt;           -- 允许对象的垃圾收集\n\n!!                        -- 重复执行最后一个命令\n&lt;n&gt; &lt;command&gt;             -- 将命令重复执行 n 次\n# &lt;command&gt;               -- 放弃 (无操作)\nhelp (或 ?)               -- 列出命令\nversion                   -- 输出版本信息\nexit (或 quit)            -- 退出调试器\n\n&lt;class id&gt;: 带有程序包限定符的完整类名\n&lt;class pattern&gt;: 带有前导或尾随通配符 (\&#39;*\&#39;) 的类名\n&lt;thread id&gt;: \&#39;threads\&#39; 命令中报告的线程编号\n&lt;expr&gt;: Java(TM) 编程语言表达式。\n支持大多数常见语法。\n\n可以将启动命令置于 \&quot;jdb.ini\&quot; 或 \&quot;.jdbrc\&quot; 中\n位于 user.home 或 user.dir 中&quot;}, {&quot;zz usage text&quot;, &quot;用法: {0} &lt;options&gt; &lt;class&gt; &lt;arguments&gt;\n\n其中, 选项包括:\n    -help             输出此消息并退出\n    -sourcepath &lt;由 \&quot;{1}\&quot; 分隔的目录&gt;\n                      要在其中查找源文件的目录\n    -attach &lt;address&gt;\n                      使用标准连接器附加到指定地址处正在运行的 VM\n    -listen &lt;address&gt;\n                      等待正在运行的 VM 使用标准连接器在指定地址处连接\n    -listenany\n                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接\n    -launch\n                      立即启动 VM 而不是等待 \&#39;\&#39;run\&#39;\&#39; 命令\n    -listconnectors   列出此 VM 中的可用连接器\n    -connect &lt;connector-name&gt;:&lt;name1&gt;=&lt;value1&gt;,...\n                      使用所列参数值通过指定的连接器连接到目标 VM\n    -dbgtrace [flags] 输出信息供调试{0}\n    -tclient          在 HotSpot(TM) 客户机编译器中运行应用程序\n    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序\n\n转发到被调试进程的选项:\n    -v -verbose[:class|gc|jni]\n                      启用详细模式\n    -D&lt;name&gt;=&lt;value&gt;  设置系统属性\n    -classpath &lt;由 \&quot;{1}\&quot; 分隔的目录&gt;\n                      列出要在其中查找类的目录\n    -X&lt;option&gt;        非标准目标 VM 选项\n\n&lt;class&gt; 是要开始调试的类的名称\n&lt;arguments&gt; 是传递到 &lt;class&gt; 的 main() 方法的参数\n\n要获得命令的帮助, 请在{0}提示下键入 \&#39;\&#39;help\&#39;\&#39;&quot;}};
<i>16</i>&nbsp;        return var1;
<i>17</i>&nbsp;    }
<i>18</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2014-12-21 15:48</div>
</div>
</body>
</html>
